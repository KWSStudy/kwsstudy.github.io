<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Korea Web Service Study Group</title>
    <link>http://kwsstudy.github.io/post/</link>
    <description>Recent content in Posts on Korea Web Service Study Group</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Jun 2016 11:00:00 +0900</lastBuildDate>
    <atom:link href="http://kwsstudy.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>데이타 체계화</title>
      <link>http://kwsstudy.github.io/post/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%B4%EA%B3%84%ED%99%94/</link>
      <pubDate>Sun, 05 Jun 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%B4%EA%B3%84%ED%99%94/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;필드-자체-캡슐화:df0f84d1496ba770be122b5112e062d8&#34;&gt;필드 자체 캡슐화&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;필드에 직접 접근하고 있는데 필드에 대한 결합이 이상해지면 get/set 메소드를 만들어 필드에 접근.&lt;/p&gt;

&lt;h5 id=&#34;동기:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;직접 접근 방식 : 절차적인 개발진행중 데이타 변경이 일어날 수 있는 소지가 있음.&lt;/li&gt;
&lt;li&gt;간접 접근 방식 : 객체지향 필드를 직접 접근하지 않으므로 정보 은닉 및 의도하지 않은 데이터 변경이 안된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;필드 자체 캡슐화를 실시해야 할 가장 절실할 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할때다. 먼저 필드를 자체 캡슐화한 후 필요할때 읽기 메서드와 쓰기 메서드를 재정의하면 된다.&lt;/p&gt;

&lt;h5 id=&#34;방법:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;필드 읽기메서드와 쓰기메서드를 작성하자.&lt;/li&gt;
&lt;li&gt;그 필드 참조 부분을 전부 찾아서 읽기 메서드와 쓰기 메서드로 고치자&lt;/li&gt;
&lt;li&gt;필드를 private로 만들자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
package com.kws.eight;

public class IntRange {
    private int _low,_high;
    
    boolean includes(int arg){
        return arg &amp;gt;= _low &amp;amp;&amp;amp; arg &amp;lt;= _high;
    }
    
    void grow(int factor){
        _high = _high * factor;
    }
    
    IntRange(int low, int high){
        _low = low;
        _high = high;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kws.eight;

public class IntRange {
    private int _low,_high;
    
    boolean includes(int arg){
        return arg &amp;gt;= get_low() &amp;amp;&amp;amp; arg &amp;lt;= get_high();
    }
    
    void grow(int factor){
        this._high = get_high() * factor;
    }

    public int get_low() {
        return _low;
    }

    public void set_low(int _low) {
        this._low = _low;
    }

    public int get_high() {
        return _high;
    }

    public void set_high(int _high) {
        this._high = _high;
    }
    
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자체 캡슐화를 실시할 때는 생성자 안에 쓰기 메서드를 사용할 때 주의해야 한다.대체로 객체가 생성된 후엔 속성을 변경하려고 쓰기 메서드를 사용하므로,쓰기 메서드에 초기화 시점과 다른 기능이 추가 됐을 수 있다고 전체할 때가 많다. 이럴땐 생성자나 별도의 초기화 메서드에서 직접 접근하게 하는 것이 좋다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kws.eight;

public class IntRange {
    private int _low,_high;
    
    IntRange(int low, int high){
        initialize(low, high);
    }
    
    private void initialize(int low, int high){
        this._low = low;
        this._high = high;
    }

    boolean includes(int arg){
        return arg &amp;gt;= get_low() &amp;amp;&amp;amp; arg &amp;lt;= get_high();
    }
    
    void grow(int factor){
        this._high = get_high() * factor;
    }

    public int get_low() {
        return _low;
    }

    public void set_low(int _low) {
        this._low = _low;
    }

    public int get_high() {
        return _high;
    }

    public void set_high(int _high) {
        this._high = _high;
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;생성자 초기화 메서드를 해두면 IntRange의 기능을 전부 재정의하면 기능을 하나도 수정하지 않고 cap을 계산에 넣을 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kws.eight;

public class CappedRange extends IntRange{
    private int _cap;
    
    CappedRange(int low, int high,int cap) {
        super(low, high);
        this._cap = cap;
    }

    public int get_cap() {
        return _cap;
    }

    public void set_cap(int _cap) {
        this._cap = _cap;
    }
    
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;데이터-값을-객체로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;데이터 값을 객체로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;데이터 항목에 데이터나 기능을 더 추가해야 할때는 데이터 항목을 객체로 전환하자.&lt;/p&gt;

&lt;h5 id=&#34;동기-1:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;p&gt;추가적인 데이터나 동작을 필요로 하는 데이터 아이템이 있을 때는 데이터 아이템을 객체로 바꾸어라.&lt;/p&gt;

&lt;h5 id=&#34;방법-1:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;데이터값을 넣을 클래스를 작성하자.그 클래스 원본 클래스 안의 값과 같은 타입의 final필드를 추가하자 그 필드를 인자로 받는 생성자와 읽기 메서드를 추가하자.&lt;/li&gt;
&lt;li&gt;원본 클래스에 든 필드의 타입을 새 클래스로 바꾸자.&lt;/li&gt;
&lt;li&gt;원본 클래스 안의 읽기 메서드를 새 클래스의 읽기 메서드를 호출하게 수정&lt;/li&gt;
&lt;li&gt;그 필드가 원본 클래스 생성자 안에 사용된다면 새 클래스의 생성자를 이용해서 필드를 대입하자.&lt;/li&gt;
&lt;li&gt;새 클래스의 새 인스턴스를 생성하게끔 읽기 메서드를 수정하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderBefore {
    private String customer;
    
    
    public String getCustomer() {
        return customer;
    }

    public void setCustomer(String customer) {
        this.customer = customer;
    }

    private static int numberOrderFor(Collection orders, String customer){
        int result = 0;
        Iterator iter = orders.iterator();
        while(iter.hasNext()){
            OrderBefore each = (OrderBefore) iter.next();
            if(each.getCustomer().equals(customer)){
                result++;
            }
        }
        return result;
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer {
    private final String name;

    public Customer(String customer) {
        this.name = customer;
    }

    public String getCustomers() {
        return this.name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderAfter {
    
    private Customer _customer;
    
    public OrderAfter(String arg) {
        this._customer = new Customer(arg);
    }
    
    public String getCustomers(){
        return _customer.getCustomers();
    }
    
    public void setCustomer(String customer){
        _customer = new Customer(customer);
    }
    
    @SuppressWarnings(&amp;quot;rawtypes&amp;quot;)
    private static int numberOrderFor(Collection orders, String customer){
        
        int result = 0;
        
        Iterator iter = orders.iterator();

        while(iter.hasNext()){
            OrderAfter each = (OrderAfter) iter.next();
            if(each.getCustomers().equals(customer)){
                result++;
            }
        }
        
        return result;
    }
    
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;값을-참조로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;값을 참조로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할땐 그 객체를 참조 객체로 전환하자.&lt;/p&gt;

&lt;h3 id=&#34;동기-2:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;참조객체는 고객이나 계좌 같은 것&lt;/li&gt;
&lt;li&gt;값 객체는 날짜나 돈 같은 것(값 객체는 전적으로 데이터 값을 통해서만 정의된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;방법-2:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;생성자를 팩토리 메서도로 전환을 실시하자.&lt;/li&gt;
&lt;li&gt;참조 객체로 접근을 담당할 객체를 정하자.&lt;/li&gt;
&lt;li&gt;객체를 미리 생성할지 사용하기 직전에 생성할지를 정하자.&lt;/li&gt;
&lt;li&gt;참조 객체를 반환하게 팩토리 메서드를 수정하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-1:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer {
    
    private final String name;
    
    public Customer(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }
    
}

public class Order {
    
    private Customer customer;
    
    public Order(String customerName){
        this.customer = new Customer(customerName);
    }

    public String getCustomer() {
        return customer.getName();
    }

    public void setCustomer(String customerName) {
        this.customer = new Customer(customerName);
    }
    
    @SuppressWarnings({ &amp;quot;unused&amp;quot;, &amp;quot;rawtypes&amp;quot; })
    private static int numberOrderFor(Collection orders, String customer){  
        int result = 0;     
        Iterator iter = orders.iterator();
        while(iter.hasNext()){
            Order each = (Order) iter.next();
            if(each.getCustomer().equals(customer)){
                result++;
            }
        }
        return result;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Customer는 값 객체다. 각 Order인스턴스에는 고유한 Customer객체가 들어 있다. 비록 모든 Customer객체는 개념상 동일한 고객을 나타내는 객체긴 하지만 말이다. 개념상 동일한 고객에 주문이 여러개 있을 경우 하나의 Customer객체만 사용하게끔 이것을 수정해야 한다. 즉 고객 이름 하나당 한개의 Customer객체만 있어야 한다.&lt;/li&gt;
&lt;li&gt;생성자를 팩토리 메서드로 전환을 적용하자.&lt;/li&gt;
&lt;li&gt;Customer객체에 다음과 같이 팩토리 메서드를 적용하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static Customer create(String name){
        return new Customer(name);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그 다음, 생성자 호출을 팩토리 메서드 호출로 수정하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public Order(String customerName){
        this.customer = Customer.create(customerName);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그 생성자 메서드를 private로 만들자&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private Customer(String name){
        this.name = name;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Customer에 한 개의 필드를 사용해서 라인 항목을 저장해 Customer클래스를 접근거점으로 만들겠다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static Dictionary _instances = new Hashtable();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그 다음 Customer인스턴스들을 요청이 있을 때 즉석에서 생성할지 아니면 미리 생성해 둘지 결졍해야 한다. 미리 생성해 두는 방식으로 하며, 시작 코드 안에 사용되는 Customer인스턴스들을 로딩하는 코드를 넣겠다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    static void loadCustomers(){
        new Customer(&amp;quot;우리 렌터카&amp;quot;).store();
        new Customer(&amp;quot;커피 자판기&amp;quot;).store();
        new Customer(&amp;quot;삼천리 가스&amp;quot;).store();
    }
    
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    private void store(){
        _instances.put(this.getName(), this);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 팩토리 메서드를 수정해서 미리 생성해둔 Customer인스턴스를 반환하게 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static Customer create(String name){
//      return new Customer(name);
//      미리 load된 객체반환
        return ((Customer) _instances.get(name));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create 메서드는 반드시 미리 생성되어 있던 Customer인스턴스를 반환하므로 메서드명 변경을 실시해서 확인해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static Customer getNamed(String name){
        return (Customer) _instances.get(name);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;참조를-값으로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;참조를 값으로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만들자.&lt;/p&gt;

&lt;h5 id=&#34;동기-3:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;작고,불변성이고 관리하기가 어려운 참조 객체가 있는 경우, 그것을 값 객체로 바꿔라.&lt;/li&gt;
&lt;li&gt;Reference의 필요 없이 변하지 않는 데이터의 값을 가지는 object를 필요로 하는 경우 Reference의 Object를 Value object로 대체함.&lt;/li&gt;
&lt;li&gt;참조 객체로 작업하는 것이 복잡해지면 참조에서 값으로 바꿀 이유가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;방법-3:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;전환할 객체가 변경불가인지 변경 가능인지 검사하자.&lt;/li&gt;
&lt;li&gt;equals 메서드와 hash메서드를 작성하자.&lt;/li&gt;
&lt;li&gt;컴파일과 테스트를 실시하자.&lt;/li&gt;
&lt;li&gt;팩토리 메서드를 삭제하고 생성자를 public으로 만들어야 좋은지 생각해보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-2:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Currency {
    private String code;

    public String getCode() {
        return code;
    }

    private Currency(String code){
        this.code = code;
    }
    
    public static void main(String[] args) {
        System.out.println(new Currency(&amp;quot;USD&amp;quot;).equals(new Currency(&amp;quot;USD&amp;quot;))); // false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currency 클래스에는 여러 인스턴스가 들어 있다. 생성자만 사용하는 것은 불가능하다.그래서 private인 것이다.
이것을 값 객체로 변환하려면 그 객체가 변경불가인지 확인해야 한다. 변경불가가 아니면 값이 변경 가능할 경우 끝없는 별칭 문제가 발생하므로 이렇게 수정하지 말어야 한다.
여기서 참조 객체는 변경 불가이므로 이제 다음과 같이 equals메서드를 정의해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean equals(Object arg){
        if(!(arg instanceof Currency)) return false;
        Currency other = (Currency)arg;
        return (code.equals(other.code));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;equals 메서드를 정의할 때 다음과 같이 hashCode 메서드도 정의해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hashCode(){
        return this.code.hashCode();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;배열을-객체로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;배열을 객체로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;배열을 구성하는 특정 원소가 별의별 의미를 지닐땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환하자.&lt;/p&gt;

&lt;h5 id=&#34;동기-4:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Array는 유사한 데이터의 집합을 담고 있어야 한다.&lt;/li&gt;
&lt;li&gt;데이터의 관리가 용이해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;방법-4:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;배열 안의 정보를 표현할 새 클래스를 작성하자. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성하자.&lt;/li&gt;
&lt;li&gt;배열 참조 부분을 전부 새 클래스 참조로 수정하자.&lt;/li&gt;
&lt;li&gt;배열의 각 원소마다 참조 코드에 사용할 읽기 메서드를 하나씩 넣자. 배열 원소의 용도를 따서 읽기 메서드 이름을 정하자.
참조 부분을 읽기 메서드 호출로 전부 수정하자. 하나의 수정을 마칠때마다 테스트를 실시하자.&lt;/li&gt;
&lt;li&gt;배열 참조 부분을 전부 메서드로 교채했으면 배열을 private로 만들자.&lt;/li&gt;
&lt;li&gt;컴파일하자.&lt;/li&gt;
&lt;li&gt;클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메서드를 수정하자.&lt;/li&gt;
&lt;li&gt;각 원소에 대한 수정을 마칠 때마다 컴파일과 테스트를 실시하자.&lt;/li&gt;
&lt;li&gt;모든 원소를 필드로 교체했으면 배열을 삭제하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;예제-3:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] row = new String[3];
row[0] = &amp;quot;Liverpool&amp;quot;;
row[1] = &amp;quot;15&amp;quot;;

String name = row[0];
int wins = Integer.parseInt(row[1]);

Performance row = new Performance();
row.setName(&amp;quot;Liverpool&amp;quot;);
row.setWins(&amp;quot;15&amp;quot;);

Performance Class

public class Performance {
    
    private String name;
    private String wings;

    public String getName() {
        return name;
    }

    public void setName(String arg) {
        this.name = arg;
    }
    
    public int getWins(){
        return Integer.parseInt(wings);
    }
    
    public void setWins(String arg){
        this.wings = arg;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;관측-데이터-복제:df0f84d1496ba770be122b5112e062d8&#34;&gt;관측 데이터 복제&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;도메인 데이터는 GUI컨트롤 안에서만 사용 가능한데,도메인 메서드가 그 데이터에 접근해야 할 땐 그 데이터를 도메인 객체로 복사하고,양측의 데이터를 동기화하는 관측 인터페이스 observer를 작성하자.&lt;/p&gt;

&lt;h5 id=&#34;동기-5:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;p&gt;계층구조가 체계적인 시스템은 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있다.아래와 같은 몇가지 이유로&amp;hellip;
 - 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우라서
 - 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡해지니까
 - GUI와 분리된 도메인 객체가 더욱 유지보수하기 쉬우니까
 - 두 부분을 서로 다른 개발자가 다루게 할 수 있으니까&lt;/p&gt;

&lt;h5 id=&#34;방법-5:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;표현 클래스를 도메인 클래스의 관측 인터페이스로 만들자.&lt;/li&gt;
&lt;li&gt;GUI클래스 안의 도메인 데이터를 대상으로 필드 자체 캡슐화를 실시하자.&lt;/li&gt;
&lt;li&gt;이벤트 핸들러 메서드 안에 쓰기 메서드 호출 코드를 추가하자. 이 쓰기 메서드는 직접 접근 방식으로 컴포넌트를 현재 값으로 수정한다.&lt;/li&gt;
&lt;li&gt;도메인 클래스 안에 데이터와 읽기/쓰기 메서드를 정의하자.&lt;/li&gt;
&lt;li&gt;쓰기 메서드가 도메인 필드에 쓰도록 참조를 수정하자.&lt;/li&gt;
&lt;li&gt;관측 인터페이스의 update메서드를 도메인 필드에서 GUI컨트롤로 데이터를 복사하게 수정하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-4:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IntervalWindow extends Frame{
    TextField _startField;
    TextField _endField;
    TextField _lengthField;
    
    class SymFocus extends FocusAdapter{
        public void focusLost(FocusEvent event){
            Object object = event.getSource();
            
            if(object == _startField){
                StartField_FocusLost(event);
            }else if(object == _endField){
                EndField_FocusLost(event);
            }else if(object == _lengthField){
                LengthField_FocusLost(event);
            }
        }
    }

    private boolean isNotInteger(String text) {
        boolean result = false;
        try{
            Integer.parseInt(text);
            result = true;
        }catch(Exception e){
            
        }
        return result;
    }
    
    void StartField_FocusLost(FocusEvent event){
        if(isNotInteger(_startField.getText())){
            _startField.setText(&amp;quot;0&amp;quot;);
        }
        calculateLength();
    }
    
    void EndField_FocusLost(FocusEvent event){
        if(isNotInteger(_endField.getText())){
            _endField.setText(&amp;quot;0&amp;quot;);
        }
        calculateLength();
    }
    
    void LengthField_FocusLost(FocusEvent event){
        if(isNotInteger(_lengthField.getText())){
            _lengthField.setText(&amp;quot;0&amp;quot;);
        }
        calculateEnd();
    }

    void calculateLength(){
        try{
            int start = Integer.parseInt(_startField.getText());
            int end = Integer.parseInt(_endField.getText());
            int length = end - start;
            _lengthField.setText(String.valueOf(length));
        }catch(NumberFormatException e){
            throw new RuntimeException(&amp;quot;잘못된 숫자 형식 에러&amp;quot;);
        }
    }
    
    void calculateEnd(){
        try{
            int start = Integer.parseInt(_startField.getText());
            int length = Integer.parseInt(_endField.getText());
            int end = start + length;
            _lengthField.setText(String.valueOf(end));
        }catch(NumberFormatException e){
            throw new RuntimeException(&amp;quot;잘못된 숫자 형식 에러&amp;quot;);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 할 일은 GUI코드와 로직코드를 분리하는 것이다. calculateLength 메서드와 calculateEnd 메서드를 별도의 도메인 클래스로 옮겨야 한다. 그러려면 start,end,length 변수를 IntervalWindow 클래스를 거치지 않고 참조해야 한다.그러기 위한 유일한 방법은 start,end,length 변수 데이터를 도메인 클래스로 복사하고 그 데이터를 GUI클래스의 데이터와 동기화하는 것이다.이 작업을 소위 관측 데이터 복제라고 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;아직 도메인 클래스가 없으니 빈 도메인 클래스를 다음과 같이 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Interval extends Observable{}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;이렇게 작성한 도메인 클래스를 참조하는 필드를 IntervalWindow클래스에 다음과 같이 넣어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class IntervalWindow....{
    private Interval _subject;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;그런 다음 이 필드를 적절히 초기화하고 IntervalWindow클래스를 Interval 도메인 클래스의 관측 인터페이스로 만들어야 한다.
그럴려면 IntervalWindow클래스의 생성자 메서드 안에 다음 코드를 넣어면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public IntervalWindowChange(){
        _subject = new Interval();
        _subject.addObserver(this);
        update(_subject, null);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;그 다음 IntervalWindow클래스가 Observer클래스를 상속구현해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IntervalWindowChange extends Frame implements Observer{}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Observer클래스를 상속구현하려면 update메서드를 오버라이드 해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override
    public void update(Observable o, Object arg) {

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;이제 필드를 옮길 차례다. 필드 자체캡슐화를 실시해서 모든 텍스트 필드는 getText메서드와 setText메서드를 통해 업데이트 한다.
읽기메서드와 쓰기 메서드를 다음과 같이 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String getEnd(){
        return _endField.getText();
    }
    
    public void setEnd(String arg){
        _endField.setText(arg);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;그런 다음 _endField필드 참조 부분을 전부 찾아서 읽기메서드나 쓰기메서드로 교체하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    void calculateLength(){
        try{
            int start = Integer.parseInt(_startField.getText());
            int end = Integer.parseInt(getEnd());
            int length = end - start;
            _lengthField.setText(String.valueOf(length));
        }catch(NumberFormatException e){
            throw new RuntimeException(&amp;quot;잘못된 숫자 형식 에러&amp;quot;);
        }
    }
    
    void calculateEnd(){
        try{
            int start = Integer.parseInt(_startField.getText());
            int length = Integer.parseInt(_lengthField.getText());
            int end = start + length;
            setEnd(String.valueOf(end));
        }catch(NumberFormatException e){
            throw new RuntimeException(&amp;quot;잘못된 숫자 형식 에러&amp;quot;);
        }
    }

    void EndField_FocusLost(FocusEvent event){
                setEnd(_endField.getText());
        if(isNotInteger(getEnd())){
            setEnd(&amp;quot;0&amp;quot;);
        }
        calculateLength();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;setEnd메서드를 호출할 때 매개변수로 getEnd메서드를 사용하지 않고 end필드를 직접 사용했다.그 이유는 리팩토링 후반부에 가서 getEnd메서드는 값을 end필드에서 가져오는게 아니라 도메인 객체를 통해 가져오기 때문이다.그때 도메인 객체로부터 값을 가져오면 사용자가 필드 값을 변경할 때마다 이 코드는 endField값을 변경 전의 값으로 되돌리게 되므로,end필드를 직접 읽어야 하는것이다.&lt;/li&gt;
&lt;li&gt;다음 Interval 도메인 클래스에 end필드와 읽기메서드와 쓰기메서드를 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String end = &amp;quot;0&amp;quot;;
    void setEnd(String arg){
        this.end = arg;
        setChanged();
        notifyObservers();
    }
    
    String getStart(){
        return start;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Interval클래스에 위와 같이 작성했으면 IntervalWindow클래스의 읽기/쓰기 메서드를 수정해서 Interval을 거치게 만들자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String getEnd(){
        return _subject.getEnd();
    }
    
    public void setEnd(String arg){
        _subject.setEnd(arg);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GUI클래스가 그 변경사항 통지에 확실히 반응하게 하려면 다음과 같이 update메서드를 수정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override
    public void update(Observable o, Object arg) {
        _endField.setText(_subject.getEnd());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;앞의 코드에서 역시 endField로의 직접 접근 방식을 사용했다. 이렇게 하지 않고 만약 쓰기 메서드를 호출하면 무한루프에 빠진다.&lt;/li&gt;
&lt;li&gt;지금껏 end필드에 수행한 과정을 start,length필드에도 그대로 적용하자. 메서드 이동 기법으로 calculaterEnd메서드와 calculaterLength메서드를 Interval클래스로 옮기자.그러면 모든 도메인 기능과 데이터는 도메인 클래스에 들어 있게 되어 GUI코드로 분리된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;클래스의-단방향-연결을-양방향으로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;클래스의 단방향 연결을 양방향으로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정하자.&lt;/p&gt;

&lt;h5 id=&#34;동기-6:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;각각 서로의 기능을 필요로 하는 클래스가 있는데 링크가 한쪽 방향으로만 되어 있는 경우, 반대 방향으로 포인터 추가하고, 수정자가 양쪽 세트를 모두 업데이트 하게 변경하라&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;방법-6:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;역 포인터 참조용 필드를 추가하자.&lt;/li&gt;
&lt;li&gt;연결 제어 기능을 어느 클래스에 넣을지 정하자.&lt;/li&gt;
&lt;li&gt;연결 제어 기능이 없는 클래스 안에 헬퍼 메서드를 작성하고, 그 메서드에 제한된 용도가 분명히 드러나는 이름을 붙이자.&lt;/li&gt;
&lt;li&gt;기존 변경 메서드가 연결 제어 클래스에 들어 있으면 역 포인터를 업데이트하게 변경 메서드를 수정하자.&lt;/li&gt;
&lt;li&gt;기존 변경 메서드가 연결 제어 클래스에 들어 있으면 제어 클래스 안에 제어 메서드를 작성하고 기존 변경 메서드가 그 메서드를 호출하게 하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-5:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Order...
    Customer getCustomer(){
        return customer;
    }    

    void setCustomer(Customer arg){
        customer = arg;
    }

class Customer{
   private Set orders = new HashSet(); 
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;클래스의-양방향-연결을-단방향으로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;클래스의 양방향 연결을 단방향으로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;두 클래스가 양방향으로 연결되어 있는 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않게 됐을 땐 불필요한 방향의 연결을 끊자.&lt;/p&gt;

&lt;h5 id=&#34;동기-7:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;p&gt;양방향 연결로 인해 두 클래스는 서로 종속된다, 한 클래스를 수정하면 다른 클래스도 변경된다.종속성이 많으면 시스템의 결합력이 사소한 수정에도 예기치 못한 각종 문제가 발생한다.&lt;/p&gt;

&lt;h5 id=&#34;방법-7:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;삭제하려는 포인터가 저장된 필드를 읽는 모든 부분을 검사해서 삭제해도 되는지 파악&lt;/li&gt;
&lt;li&gt;참조 코드가 속성 읽기 메서드를 사용해여 한다면 속성 읽기 메서드에 필드 자체 캡슐화를 적용하고 알고리즘 전환&lt;/li&gt;
&lt;li&gt;참조 코드에 읽기 메서드 호출을 넣을 필요가 없다면 각 필드 사용 부분을 찾아서 필드 안의 객체를 다른 방법으로 가져오게끔 수정&lt;/li&gt;
&lt;li&gt;필드 안의 속성 읽기 메서드를 모두 삭제했으면 필드 업데이트 코드 전부와 필드를 삭제하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-6:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Order {
    private Customer customers;

    public Customer getCustomer() {
        return customers;
    }

    public void setCustomer(Customer arg) {
        // this.customer = customer;
        if (customers != null)
            customers.friendOrders().remove(this);
        customers = arg;
        if (customers != null)
            customers.friendOrders().add(this);
    }
}

public class Customer {
    private static Set orders = new HashSet();
    
    void addOrder(Order arg){
        arg.setCustomer(this);
    }
    
    Set friendOrders(){
        return orders;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;예제 프로그램을 보니 customer가 먼저 있어야만 order가 있음을 알수 있다. 따라서 Order클래스에서 Customer클래스로 가는 연결을 끊어야 한다.&lt;/li&gt;
&lt;li&gt;우선 모든 필드 읽기 메서드와 그 읽기 메서드를 사용하는 메서드들을 파악해야 한다.Customer객체를 제공할 다른 방법이 있을까?
한 명령을 Customer객체에 하나의 매개변수로 전달하는 방법을 사용할 때가 많다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Order...
    double getDiscountedPrice(Customer customer) {
        return getGrossPrice() * (1 - customer.getDiscount());
    }
Customer...
    double getPriceFor(Order order){
        return order.getDiscountedPrice(this);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;마법숫자를-기호-상수로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;마법숫자를 기호 상수로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체하자.&lt;/p&gt;

&lt;h5 id=&#34;방법-8:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;상수를 선언하고 그상수에 마법 숫자의 값을 할당.&lt;/li&gt;
&lt;li&gt;마법 숫자 사용되는 부분 모두 찾아내고 마법 숫자가 상수의 용도와 맞는지 확인하고 그렇다면 마법 숫자를 상수로 교체하자&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-7:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    double potentiaEnergy(double mass, double height){
        return mass * 9.81 * height;
    }
    
    static final double GRAVITATION_CONSTANT = 9.81;
    
    double potentiaEnergys(double mass, double height){
        return mass * GRAVITATION_CONSTANT * height;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;필드-캡슐화:df0f84d1496ba770be122b5112e062d8&#34;&gt;필드 캡슐화&lt;/h3&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;동기-8:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;객체지향의 주요 원칙 중 하나는 캡슐화다. 캡슐화는 데이터 은닉이라고 부르기도 한다. 그래서 데이터는 절대로 public타입으로 선언하면 안된다. 데이터를 public타입으로 만들면 데이터가 있는 객체가 모르는 사이에 다른 객체가 데이터 값을 읽고 변경할 수 있다.
이로 인해 데이터와 기능을 분리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;방법-9:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;캡슐화할 필드를 읽고 쓰기 위한 메서드와 쓰기 메서드를 작성하자.&lt;/li&gt;
&lt;li&gt;클래스 외부에서 그 필드를 참조하는 모든 부분을 찾자.찾아낸 참조 부분이 값을 읽는 코드라면 그 참조 부분을 읽기 메서드 호출로 수정하고,값을 변경하는 코드라면 쓰기 메서드 호출로 수정하자.&lt;/li&gt;
&lt;li&gt;필드를 참조하는 부분을 전부 수정했으면 그 필드의 선언 타입을 private로 수정하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-8:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String name;

--------------------------------------

private String name;

public String getName(){return name;}
public void setName(String arg){name = arg;}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;컬렉션-캡슐화:df0f84d1496ba770be122b5112e062d8&#34;&gt;컬렉션 캡슐화&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;메서드가 컬렉션을 반환할때 그 메서드가 읽기전용 뷰를 반환하게 수정하고 추가메서드와 삭제메서드를 작성하자.&lt;/p&gt;

&lt;h5 id=&#34;동기-9:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;p&gt;컬렉션은 다른 종류의 데이터와는 약간 다른 읽기/쓰기 방식을 사용해야 한다. 읽기 메서드는 컬렉션 객체 자체를 반환해선 안된다.
왜냐하면 컬렉션 참조 부분이 컬렉션의 내용을 조작해도 그 컬렉션이 든 클래스는 무슨 일이 일어나는지 모르기 때문이다.이로 인해 컬렉션 참조 코드에서 그 객체의 데이터 구조가 지나치게 노출된다.값이 여러 개인 속성을 읽는 읽기 메서드는 컬렉션 조작이 불가능한 형식을 반환하고 불필요하게 자세한 컬렉션 구조 정보는 감춰야 한다.
컬렉션 쓰기 메서드는 절대 있으면 안되므로, 원소를 추가하는 메서드와 삭제하는 메서드를 대신 사용해야 한다.&lt;/p&gt;

&lt;h5 id=&#34;방법-10:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;컬렉션 원소를 추가하는 add메서드와 remove메서드를 추가하자.&lt;/li&gt;
&lt;li&gt;필드를 빈 컬렉션으로 초기화하자.&lt;/li&gt;
&lt;li&gt;쓰기 메서드 호출 부분을 찾아서 add메서드와 remove메서드 호출로 바꾸던지, 그 위치에 직접 컬렉션에 원소를 추가하고 삭제하는 코드를 작성하자.&lt;/li&gt;
&lt;li&gt;set이라는 이름을 initalize와 replace로 수정하자.&lt;/li&gt;
&lt;li&gt;읽기 메서드를 호출하여 컬렉션을 변경하는 부분을 전부 찾아서,add메서드 호출과 remove메서드호출로 바꾸자.
6.컬렉션을 변경하고자 읽기 메서드를 호출하는 부분을 전부 추가/삭제 메서드 호출로 고쳤으면,컬렉션의 읽기 전용 뷰를 반환하게 읽기 메서드를 수정하자.&lt;/li&gt;
&lt;li&gt;읽기 메서드 호출 부분을 찾고 컬렉션이 든 객체로 옮겨야 할 코드를 찾아서 메서드추출과 메서드이동을 실시해서 컬렉션이 든 객체로 옮기자.&lt;/li&gt;
&lt;li&gt;기존 읽기 메서드에 메서드명 변경을 적용하고,Enumeration타입을 반환하는 새 메서드를 작성하고,기존 메서드 호출 부분을 새 메서드 호출로 바꾸지.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-9:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package collection;

public class Course {
    
    private String name;
    private boolean isA;
    
    public Course(String name, boolean isAdvanced){
        this.name = name;
        this.isA = isAdvanced;
    }
    
    public boolean isAdvanced(){
        return true;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package collection;

import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import junit.framework.Assert;

public class Person {
    
//  private Set course;
    @SuppressWarnings(&amp;quot;rawtypes&amp;quot;)
    private Set course = new HashSet();

    public Set getCourse() {
        return course;
    }
    
//  @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
//  public Set getCourse() {
//      return Collections.unmodifiableSet(course);
//      unmodifiableSet 메소드는 지정된 세트의 변경 불가능한 뷰를 돌려줍니다.
//  }

//  초기화하려고 원소를 추가할때 추가 기능이 확실히 필요 없다면 다음과 같이 루프를 삭제하고 addAll메서드를 사용.
//  public void setCourse(Set course) {
//      this.course = course;
//  }
    
    @SuppressWarnings(&amp;quot;rawtypes&amp;quot;)
    public void initalizeCourse(Set arg) {
//      Assert.isTrue(course.isEmpty());
        Iterator iter = arg.iterator();
        while(iter.hasNext()){
            addCourse((Course) iter.next());
        }
    }
    
//  public void initalizeCourse(Set arg) {
//      Assert.isTrue(course.isEmpty());
//      course.addAll(arg);
//  }
    
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public void addCourse(Course arg){
        course.add(arg);
    }
    
    public void removeCourse(Course arg){
        course.remove(arg);
    }
    
    
    @SuppressWarnings(&amp;quot;rawtypes&amp;quot;)
    int numberOfAdvancedCourse(Person person){
        Iterator iter = person.getCourse().iterator();
        
        int count = 0;
        
        while(iter.hasNext()){
            Course each = (Course) iter.next();
            if(each.isAdvanced()){
                count++;
            }
        }
        
        return count;
    }
    
    int numberOfCourse(){
        return course.size();
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package collection;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.junit.Assert;


public class Client {
    
    @SuppressWarnings({ &amp;quot;rawtypes&amp;quot;, &amp;quot;unchecked&amp;quot; })
    public static void main(String[] args) {
        
        Person kent = new Person();
        
        Set s = new HashSet();
        
//      before
//      s.add(new Course(&amp;quot;스몰토크 프로그래밍&amp;quot;, false));
//      s.add(new Course(&amp;quot;싱글몰드 위스키 음미하기&amp;quot;, true));
        
//      after
        kent.addCourse(new Course(&amp;quot;스몰토크 프로그래밍&amp;quot;, false));
        kent.addCourse(new Course(&amp;quot;싱글몰드 위스키 음미하기&amp;quot;, true));
        
//      kent.setCourse(s);
        kent.initalizeCourse(s);
        
//      Assert.assertEquals(2, kent.getCourse().size());
        Course refact = new Course(&amp;quot;리팩토링&amp;quot;, true);
        
        kent.getCourse().add(refact);
        
//      before
//      kent.getCourse().add(new Course(&amp;quot;지독한 빈정거림&amp;quot;, false));
//      after
        kent.addCourse(new Course(&amp;quot;지독한 빈정거림&amp;quot;, false));
        
//      Assert.assertEquals(4, kent.getCourse().size());
        
        kent.getCourse().remove(refact);
        
//      Assert.assertEquals(3, kent.getCourse().size());
        
//      System.out.println(kent.getCourse().size());
        System.out.println(kent.getCourse());
        //고급과정
        Iterator iter = kent.getCourse().iterator();
        
        int count = 0;
        
        while(iter.hasNext()){
            Course each = (Course) iter.next();
            if(each.isAdvanced()){
                count++;
            }
        }
        
        System.out.println(count);
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package collection;

import java.util.Enumeration;
import java.util.Vector;

public class PersonVecter {
    
    private Vector course;

    public Vector getCourse() {
        return course;
    }

    public void setCourse(Vector course) {
        this.course = course;
    }
    
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public void addCourse(Course arg){
        course.addElement(arg);
    }
    
    public void removeCourse(Course arg){
        course.removeElement(arg);
    }
    
    @SuppressWarnings(&amp;quot;rawtypes&amp;quot;)
    public void initalizeCourse(Vector arg) {
//      Assert.isTrue(course.isEmpty());
        Enumeration iter = arg.elements();
        while(iter.hasMoreElements()){
            addCourse((Course) iter.nextElement());
        }
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package collection;

public class ArrayTest {
    
    private String[] skills;

//  public String[] getSkills() {
//      return skills;
//  }
    public String[] getSkills() {
        String[] result = new String[skills.length];
        System.arraycopy(skills, 0, result, 0, skills.length);
        return result;
    }
    
//  public void setSkills(String[] arg) {
//      this.skills = skills;
//  }
    
    public void setSkill(int index, String skill) {
        skills = new String[5];
        skills[index] = skill;
    }
    
    public void setSkills(String[] arg) {
        skills = new String[skills.length];
        for(int i = 0; i &amp;lt; skills.length; i++){
            setSkill(i,arg[i]);
        }
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;레코드를-데이터-클래스로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;레코드를 데이터 클래스로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;전통적인 프로그래밍 환경에서의 레코드 구조에 대한 인터페이스가 필요한 경우, 그 레코드를 위한 데이터 객체를 만들어라.&lt;/p&gt;

&lt;h5 id=&#34;방법-11:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;레코드를 표현할 클래스를 작성하자.&lt;/li&gt;
&lt;li&gt;그 클래스에 각 데이터 항목에 대한 읽기 메서드와 쓰기 메서드를 작성하고 private필드를 선언하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;분류-부호를-클래스로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;분류 부호를 클래스로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;기능에 영향을 숫자형 분류 부호가 든 클래스가 있을 땐 그 숫자를 새 클래스로 바꾸자.&lt;/p&gt;

&lt;h5 id=&#34;동기-10:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;숫자형 분류 부호를 클래스로 빼내면 컴파일러는 그 클래스 안에서 종류 판단을 수핼할 수 있다. 그 클래스 안에 팩토리 메서드를 작성하면 유효한 인스턴스만 생성되는지와 그런 인스턴스가 적절한 객체로 전달되는지를 정적으로 검사할 수 있다.&lt;/li&gt;
&lt;li&gt;분류 부호를 클래스로 만드는 건 분류 부호가 순수한 데이터일 때만 실시해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;방법-12:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;분류 부호의 종류를 판단랑 새 클래스를 작성하자.&lt;/li&gt;
&lt;li&gt;새 클래스를 사용하게 원본 클래스의 내용을 수정하자.&lt;/li&gt;
&lt;li&gt;원본 클래스 코드를 사용하는 원본 클래스 안의 각 메서드마다, 그에 대응하는 새 캘르스를 사용하는 새 메서드를 사용하자.&lt;/li&gt;
&lt;li&gt;원본 클래스 호출 부분을 한 번에 하나씩 새 인터페이스 호출로 수정하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-10:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class Person{
    public static final int O = 0;
    public static final int A = 1;
    public static final int B = 2;
    public static final int AB = 3;

    private int bloodGroup;

    public Person(int bloodGroup){
        this.bloodGroup = bloodGroup;
    }

    public void setBloodGroup(int arg){
        this.bloodGroup = arg;
    }

    public int getBloodGroup(){
        return bloodGroup
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package replace;

public class Person {
    
    private BloodGroup bloodgroup;
    
    public static final int O = BloodGroup.O.getCode();
    public static final int A = BloodGroup.A.getCode();
    public static final int B = BloodGroup.B.getCode();
    public static final int AB = BloodGroup.AB.getCode();
    
//  private int bloodGroup;
    
    public Person(BloodGroup arg){
//      this.bloodGroup = arg;
        this.bloodgroup = arg;
    }

    public BloodGroup getBloodGroup() {
//      return bloodGroup;
        return bloodgroup;
    }

    public void setBloodGroup(BloodGroup arg) {
        this.bloodgroup = arg;
    }
    
    public static void main(String[] args) {
        
//      Person thePerson = new Person(Person.A);
        Person thePerson = new Person(BloodGroup.A);
        
        thePerson.getBloodGroup().getCode();
        
//      thePerson.setBloodGroup(Person.AB);
        thePerson.setBloodGroup(BloodGroup.AB);
    }
}

package replace;

public class BloodGroup {
    
    public static final BloodGroup O = new BloodGroup(0);
    public static final BloodGroup A = new BloodGroup(1);
    public static final BloodGroup B = new BloodGroup(2);
    public static final BloodGroup AB = new BloodGroup(3);
    private static final BloodGroup[] values = {O ,A ,B ,AB};
    
    private final int code;
    
    private BloodGroup(int arg){
        this.code = arg;
    }

    public int getCode() {
        return code;
    }

    public static BloodGroup code(int arg){
        return values[arg];
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;분류-부호를-하위클래스로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;분류 부호를 하위클래스로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;클래스 기능에 영향을 주는 변경불가 분류 부호가 있을 땐 분류 부호를 하위클래스로 만들자&lt;/p&gt;

&lt;h5 id=&#34;동기-11:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;분류 부호의 값이 객체 생성 후 변할때&lt;/li&gt;
&lt;li&gt;다른 이유로 분류 부호를 이미 하위클래스로 만들었을때&lt;/li&gt;
&lt;li&gt;분류 부호를 상태/전략 패턴으로 전환을 실시해야 할때&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;분류 부호를 하위클래스로 전환 기법은 주로 조건문을 재정의로 전환을 가능하게 하는 사전 작업으로 시행할 때가 많다. 분류 부호를 하위클래스로 전환기법은 조건문이 있으면 실시한다.&lt;/p&gt;

&lt;p&gt;특정 분류 부호의 객체에만 관련된 기능이 있을 때도 분류 부호를 하위클래스로 전환 기법을 적용해야 한다.&lt;/p&gt;

&lt;h5 id=&#34;방법-13:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;분류 부호를 캡슐화 하자.&lt;/li&gt;
&lt;li&gt;각 분류 부호 값마다 그에 해당하는 하위클래스를 작성하자. 그 하위클래스 안에 관련 값을 반환하는 분류 부호 읽기 메서드를 정의하자.&lt;/li&gt;
&lt;li&gt;상위클래스의 분류 부호 필드를 삭제하자. 분류 부호 읽기 메서드와 쓰기 메서드를 abstract타입으로 선언하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-11:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package subclass;

abstract class Employee {
    private int type;

    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;

    static Employee create(int arg) {
        switch (arg) {
        case ENGINEER:
            return new Engineer(0);
        case SALESMAN:
//          return new Salesman();
        case MANAGER:
//          return new Manage();
        default:
            throw new IllegalArgumentException(&amp;quot;Incorrect&amp;quot;);
        }
    }

    public Employee(int arg) {
        this.type = arg;
    }

    // public int getType() {
    // return type;
    // }

    abstract int getType();

    public void setType(int type) {
        this.type = type;
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package subclass;

public class Engineer extends Employee{

    public Engineer(int arg) {
        super(arg);
    }

    public int getType(){
        return Employee.ENGINEER;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;분류-부호를-상태-전략-패턴으로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;분류 부호를 상태/전략 패턴으로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;분류 부호가 클래스의 기능에 영향을 주지만 하위클래스로 전환할 수 없을 땐 그 분류 부호를 상태 객체로 만들자.&lt;/p&gt;

&lt;h5 id=&#34;동기-12:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;클래스의 동작에 영향을 미치는 타입 코드가 있지만 서브클래싱을 할 수 없을 때는 타입 코드를 스테이트(State) 객체로 바꿔라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;방법-14:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;분류 부호를 캡슐화하자.&lt;/li&gt;
&lt;li&gt;분류 부호의 목적을 나타내는 이름으로 새 클래스를 작성하자. 이것이 상태객체다.&lt;/li&gt;
&lt;li&gt;그 상태 객체에 각 분류 부호에 해당하는 하위클래스로 추가하자.&lt;/li&gt;
&lt;li&gt;상태 객체 안에 분류 코드를 반환하는 abstract 메서드 호출로 작성하자. 올바른 분류 부호를 반환하는 상태 객체 하위클래스 각각에 대한 재정의 메서드 호출을 작성하자.&lt;/li&gt;
&lt;li&gt;원본 클래스 안에 새 상태 객체를 나타내는 필드에 선언하자.&lt;/li&gt;
&lt;li&gt;원본 클래스에 있는 분류 부호 판단 코드를 상태 객체에 위임하게 수정하자.&lt;/li&gt;
&lt;li&gt;원 본 클래스의 분류 부호 쓰기 메서드를 적절한 상태 객체 하위클래스의 인스턴스를 할당하게 수정하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-12:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Employee {
    private EmployeeType type;

    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    
    private int monthlySalary = 0;
    private int commission = 0;
    private int bonus = 0;

    public Employee(EmployeeType arg) {
        this.type = arg;
    }

    public void setType(int arg) {
          this.type = type;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;이제 상태클래스를 선언하자.상태 클래스는 abstract타입으로 선언하고 그 안에 분류부호를 반환하는 abstract메서드를 선언하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class EmployeeType {
    abstract int getTypeCode();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;그리고 다음과 같이 분류 부호별 하위클래스를 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Engineer extends EmployeeType{
    int getTypeCode() {
        return Employee.ENGINEER;
    }
}

public class Manager extends EmployeeType{
    int getTypeCode() {
        return Employee.MANAGER;
    }
}

    int getTypeCode() {
        return Employee.SALESMAN;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;이제 분류 부호 읽기/쓰기 메서드를 수정해서 하위클래스 Employee클래스를 연결하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private EmployeeType type;
    
    int getType(){
        return type.getTypeCode();
    }

    public void setType(int arg) {
//        this.type = type;

        switch (arg) {
        
        case ENGINEER:
            type = new Engineer();
            break;
        case SALESMAN:
            type = new Salesman();
            break;
        case MANAGER:
            type = new Manager();
            break;
        default:
            throw new IllegalArgumentException(&amp;quot;사원 부호가 잘못됨.&amp;quot;);
        }
        
        type = EmployeeType.newType(arg);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;분류 부호를 상태/전략 패턴으로 전환&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Employee...  
    public void setType(int arg) {
        type = EmployeeType.newType(arg);
    }

EmployeeType...
    static EmployeeType newType(int code){
        switch (code) {
        case ENGINEER:
            return new Engineer();
        case SALESMAN:
            return new Salesman();
        case MANAGER:
            return  new Manager();
        default:
            throw new IllegalArgumentException(&amp;quot;사원 부호가 잘못됨.&amp;quot;);
        }
    }

Employee...
    int payAmount(int arg) {
        switch (arg) {
        case EmployeeType.ENGINEER:
            return monthlySalary;
        case EmployeeType.SALESMAN:
            return  monthlySalary + commission;
        case EmployeeType.MANAGER:
            return  monthlySalary + bonus;
        default:
            throw new IllegalArgumentException(&amp;quot;Incorrect&amp;quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;하위클래스를-필드로-전환:df0f84d1496ba770be122b5112e062d8&#34;&gt;하위클래스를 필드로 전환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;여러 하위클래스가 상수 데이터를 반환하는 메서드만 다른땐 각 하위클래스의 메서드를 상위클래스 필드로 전환하고 하위클래스는 전부 삭제하라.&lt;/p&gt;

&lt;h5 id=&#34;동기-13:df0f84d1496ba770be122b5112e062d8&#34;&gt;동기&lt;/h5&gt;

&lt;p&gt;기능을 추가하거나, 동작의 변화를 허용하기 위해서 서브클래스를 만든다.
동작 변화의 한 형태는 상수메소드(하드 코딩된 값을 리턴하는 메소드)이다.
상수메소드는 유용하기는 하지만, 상수 메소드를 포함하고 있는 서브클래스는 존재할 가치가 있을 만큼 충분한 일을 하는 것이 아니다.
서브클래스를 사용하면서 생기는 여러 복잡성을 제거할 수 있다.&lt;/p&gt;

&lt;h5 id=&#34;방법-15:df0f84d1496ba770be122b5112e062d8&#34;&gt;방법&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;하위클래스에 생성자를 팩토리 메서드로 전환&lt;/li&gt;
&lt;li&gt;하위클래스 참조 부분을 전부 상위클래스 참조로 수정&lt;/li&gt;
&lt;li&gt;상위클래스에 각 상수 메서드에 대한 final타입의 필드를 선언&lt;/li&gt;
&lt;li&gt;protected타입의 상위클래스 생성자를 선언해서 필드를 초기화&lt;/li&gt;
&lt;li&gt;하위클래스 생성자를 추가하거나 수정해서 새 상위클래스 생성자를 호출하자&lt;/li&gt;
&lt;li&gt;상위클래스 안에 필드를 반환하는 각 상수 메서드를 구현하고 하위클래스의 메서드는 삭제하자.&lt;/li&gt;
&lt;li&gt;하위클래스 메서드를 전부 삭제했으면 메서드 내용 직접삽입 기법을 실시해서 생성자 메서드 내용을 상위클래스의 팩토리 메서드에 넣자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;예제-13:df0f84d1496ba770be122b5112e062d8&#34;&gt;예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class Person {
    abstract boolean isMale();
    abstract char getCode();
}

public class Maie extends Person{

    @Override
    boolean isMale() {
        return true;
    }

    @Override
    char getCode() {
        return &#39;M&#39;;
    }

}

public class Female extends Person{

    @Override
    boolean isMale() {
        return false;
    }

    @Override
    char getCode() {
        return &#39;F&#39;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Male하위클래스와 Female하위클래스는 하위클래스는 하드 코딩된 상수 메서드반환만 다르다.&lt;/li&gt;
&lt;li&gt;생성사를 팩토리 메서드로 전환&lt;/li&gt;
&lt;li&gt;상위클래스에 다음과 같이 각 상수 메서드별 필드를 선언하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    static Person createMale(){
        return new Person(true,&#39;M&#39;);
    }
    
    static Person createFemale(){
        return new Person(false,&#39;F&#39;);
    }

    private final boolean _isMale;
    private final char _code;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>객체 간의 기능 이동</title>
      <link>http://kwsstudy.github.io/post/%EA%B0%9D%EC%B2%B4-%EA%B0%84%EC%9D%98-%EA%B8%B0%EB%8A%A5-%EC%9D%B4%EB%8F%99/</link>
      <pubDate>Sun, 29 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EA%B0%9D%EC%B2%B4-%EA%B0%84%EC%9D%98-%EA%B8%B0%EB%8A%A5-%EC%9D%B4%EB%8F%99/</guid>
      <description>

&lt;h3 id=&#34;객체-간-이동이-가능한-상황-및-상황별-리팩토링-기법:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;객체 간 이동이 가능한 상황 및 상황별 리팩토링 기법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;기능을 넣을 적절한 위치를 찾는 경우&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메서드 이동(Move Method)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;필드 이동(Move Field)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;방대해진 클래스의 정리 또는 클래스 기능이 너무 적은 경우&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;클래스 추출(Extract Class)&lt;/strong&gt; - 기능이 너무 많아 방대해진 클래스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;클래스 직접 삽입(Inline Class)&lt;/strong&gt; - 리팩토링 결과로 클래스 내에 기능이 너무 작아진 경우 다른 클래스로 합침&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;다른 클래스(대리 클래스)를 이용할 경우&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;대리 객체 은폐(Hide Delegate)&lt;/strong&gt; - 대리 클래스가 사용 중이라는 것을 외부에 감춤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;과잉 중개 메서드 제거(Remove Middle Man)&lt;/strong&gt; - 대리 객체 은폐시 대리 클래스를 사용 중인 클래스의 인터페이스가 변경될 때&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;클래스의 원본 코드에 접근할 수 없는 상황에서 수정 불가능한 클래스의 기능을 이동해야 할 때&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;외래 클래스에 메서드 추가(Introduce Foreign Method)&lt;/strong&gt; - 기능을 이동할 메서드가 한두개 뿐일 때&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;국소적 상속확장 클래스 사용(Introduce Local Extension)&lt;/strong&gt; - 기능을 이동할 메서드가 세개 이상일 때&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;메서드-이동-move-method:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;메서드 이동 (Move Method)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 사용할 때&lt;br /&gt;
→ &lt;em&gt;그 메서드가 가장 많이 이용하는 클래스 안에서 비슷한 내용의 메서드를 작성&lt;/em&gt;&lt;br /&gt;
→ &lt;em&gt;기존 메서드는 간단한 대리 메서드로 전환하던지 아예 삭제&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;언제 적용하는게 좋을까?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;클래스에 기능이 너무 많을 경우&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;클래스가 다른 클래스와 과하게 연동되어 의존성이 지나칠 때&lt;br /&gt;
▶ &lt;em&gt;자신이 속한 객체보다 다른 객체를를 더 많이 참조하는 메서드&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;어떤 이점을 가져올 수 있을까?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;클래스가 간결해짐&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;기능의 구현이 명확해짐&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;방법:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;원본 클래스에 정의되어 있는 &lt;strong&gt;원본 메서드에 사용된 모든기능을 검사하고 그 기능들도 옮겨야할지를 판단&lt;/strong&gt;한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;옮길 메서드에서만 사용되는 기능은 함께 옮겨야함&lt;/li&gt;
&lt;li&gt;옮길 메서드와 함께 옮길 기능이 다른 메서드에서도 사용된다면 그 메서드도 함께 옮기는 것을 고려함&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 클래스의 &lt;strong&gt;하위클래스와 상위클래스에서 그 메서드에 대한 다른 선언&lt;/strong&gt;이 있는지 검사&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;다른 선언이 있다면 대상 클래스에도 재정의를 넣을 수 있을 때만 옮길 수 있을지도 모름&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 메서드에 대응되는 &lt;strong&gt;대상 메서드를 대상 클래스에 선언&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;대상 클래스 안에 있을 때 더욱 어울리는 다른 이름으로 메서드를 정의해도 됨&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 메서드의 코드를 대상 메서드에 복사한 후, 대상 클래스 안에서 잘 돌아가게끔 &lt;strong&gt;대상 메서드를 수정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;대상 메서드가 원본 객체를 사용한다면 대상 메서드 안에서 원본 객체를 참조할 방법을 정한다.&lt;/li&gt;
&lt;li&gt;대상 클래스에 원본 클래스를 참조&lt;/li&gt;
&lt;li&gt;원본 객체를 매개변수로 전달&lt;/li&gt;
&lt;li&gt;대상 메서드에 예외처리 코드가 있다면 예외를 논리적으로 어느 클래스가 처리할지 결정&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;대상 클래스를 컴파일&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 객체에서 대상 객체를 참조할 방법의 결정&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;대상 클래스를 참조하는 속성이나 메서드가 있는지 확인하고 없으면 만든다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;원본 메서드를 위임 메서드로 전환&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일과 테스트&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;위임 메서드로 변경된 &lt;strong&gt;원본 메서드를 삭제&lt;/strong&gt;하던지 위임 메서드로 계속 사용하도록 함&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;참조가 많을 때는 원본 메서드를 위임 메서드로 내버려두는 방법이 편함&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 메서드를 삭제할 때는 기존의 참조를 전부 &lt;strong&gt;대상 메서드 참조로 수정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;찾아바꾸기 기능을 이용해 한 번 실행으로 일괄적으로 바꿔도 됨&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일과 테스트&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Account {
    private AccountType _type;
    private int _daysOverdrawn;

    ...

    double overdraftCharge() {
        if (_type.isPremium()) {
            double result = 10;
            if (_daysOverdrawn &amp;gt; 1) {
                result += (_daysOverdrawn - 7) * 0.85;
            }
            return result;
        } else {
            return _daysOverdrawn * 1.75;
        }
    }

    double bankCharge() {
        double result = 4.5;
        if (_daysOverdrawn &amp;gt; 0) {
            result += overdraftCharge();
        }
        return result;
    }

    ...
}

public class AccountType {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;
* 계좌 유형(&lt;code&gt;AccountType&lt;/code&gt;)이 추가적으로 생길 수 있는 상황에서 각 계좌 유형에 따라 다를 수 있는 &lt;code&gt;overdraftCharge&lt;/code&gt; 메서드를 &lt;code&gt;AccountType&lt;/code&gt; 클래스로 이동&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Account {
    ...
    // 삭제
    //double overdraftCharge() {
    //    return _type.overdraftCharge(_daysOverdrawn);
    //}
    
    double bankCharge() {
        double result = 4.5;
        if (_daysOverdrawn &amp;gt; 0) {
            result += _type.overdraftCharge(_daysOverdrawn);
        }
        return result;
    }
    ...
}

public class AccountType {
    ...
    double overdraftCharge(int daysOverdrawn) {
        if (isPremium()) {
            double result = 10;
            if (daysOverdrawn &amp;gt; 7) {
                result += (daysOverdrawn - 7) * 0.85;
            }
            return result;
        } else {
            return daysOverdrawn * 1.75;
        }
    }
    ...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;필드-이동-move-field:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;필드 이동 (Move Field)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용될 때는&lt;br /&gt;
→ &lt;em&gt;대상 클래스 안에 새 필드를 선언하고 그 필드 참조 부분을 전부 새 필드 참조로 수정&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-1:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;언제 적용하는게 좋을까?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;어떤 필드가 자신이 속한 클래스보다 다른 클래스에 있는 메서드들이 많이 참조하여 사용하는 경우&lt;br /&gt;
▶ &lt;em&gt;인터페이스에 따라 메서드를 옮길 수 도 있겠지만, 메서드의 위치가 올바르다고 판단되는 경우에는 필드를 옮긴다.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;클래스 추출(Extract Class) 를 실시하는 경우&lt;br /&gt;
▶ &lt;em&gt;필드의 이동이 메서드의 이동보다 우선한다.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;방법-1:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;필드가 &lt;code&gt;public&lt;/code&gt;이면 &lt;strong&gt;필드 캡슐화(Encapsulate Field)&lt;/strong&gt; 기법을 실시&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;필드에 자주 접근하는 메서드를 옮기게 될 가능성이 높거나 그 필드에 많은 메서드가 접근할 때는 필드 자체 캡슐화(Self Encapsulate Field)를 실시&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일과 테스트&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;대상 클래스 안에 &lt;strong&gt;읽기/쓰기 메서드와 함께 필드를 작성&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;대상 클래스를 컴파일&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 객체에서 &lt;strong&gt;대상 객체를 참조할 방법&lt;/strong&gt;을 정함&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원본 클래스에서 필드가 옮겨진 대상 클래스에 대한 객체를 참조할 수 있도록 방법을 마련&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 클래스에서 &lt;strong&gt;필드를 삭제&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 필드를 참조하는 모든 부분을 대상 클래스에 있는 &lt;strong&gt;적절한 메서드를 참조하게 수정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;필드에 대한 읽기: getter 를 이용&lt;/li&gt;
&lt;li&gt;핃들에 대한 쓰기: setter 를 이용&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일과 테스트&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-1:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Account {
    ...
    private AccountType _type;
    private double _interestRate;
    
    double interestForAmount_days(double amount, int days) {
        return _interestRate * amount * days / 365;
    }
    ...
}

public class AccountType {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;이자율을 나타내는 &lt;code&gt;_interestRate&lt;/code&gt; 필드를 계좌 유형에 따라 이자율이 변경될 수 있다는 생각하에 &lt;code&gt;AccountType&lt;/code&gt; 클래스로 옮기려 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;필드 캡슐화 (Encapsulate Field)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccountType {
    ...
    private double _interestRate;

    public double getInterestRate() {
        return _interestRate;
    }

    public void setInterestRate(double interestRate) {
        _interestRate = interestRate;
    }
    ...
}

public class Account {
    private AccountType _type;
    //private double _interestRate; 삭제

    ...
    public double interestForAmount_days(double amount, int days) {
        return _type.getInterestRate() * amount * days / 365;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;필드 자체 캡슐화 (Self Encapsulate Field)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;많은 메서드가 &lt;code&gt;interestRate&lt;/code&gt; 필드를 사용한다면 내부적인 변화에 대응하기 쉽도록 필드에 대한 캡슐화(getter, setter)를 생성하여 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Account {
    private AccountType _type;
    ...
    public double interestForAmount_days(double amount, int days) {
        return getInterestRate() * amount * days / 365;
    }
    
    private void setInterestRate(double arg) {
        _type.setInterestRate(arg);
    }
    
    private double getInterestRate() {
        return _type.getInterestRate();
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;클래스-추출-extract-class:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;클래스 추출 (Extract Class)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 경우&lt;br /&gt;
→ &lt;em&gt;새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮김&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-2:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;클래스는 확실하게 &lt;strong&gt;추상화 되어야하며, 두세 가지의 명확한 기능을 담당&lt;/strong&gt;해야 함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;방대한 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;개발자는 클래스에 점증적으로 기능이나 데이터를 추가 → 클래스의 방대화&lt;/li&gt;
&lt;li&gt;별도의 클래스로 만들기에는 사소한 기능의 추가가 계속되면 클래스의 복잡도가 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;어느 부분에 적용해야 하나?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;데이터의 일부분과 메서드의 일부분이 한 덩어리인 경우&lt;/li&gt;
&lt;li&gt;함께 변화된 코드들&lt;/li&gt;
&lt;li&gt;유난히 의존적인 데이터의 일부분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;판단 방법&lt;/strong&gt;&lt;br /&gt;
데이터나 메서드를 하나 제거하면 어떻게 될지, 다른 필드와 메서드를 추가하는 건 합리적이지 않은지 자문해 본다.&lt;/p&gt;

&lt;h3 id=&#34;방법-2:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;클래스의 &lt;strong&gt;기능 분리 방법을 결정&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;분리한 기능을 넣을 &lt;strong&gt;새 클래스를 작성&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 클래스에서 새 클래스로의 &lt;strong&gt;링크를 생성&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;옮길 필드마다 &lt;strong&gt;필드 이동&lt;/strong&gt;(Move Field)을 적용&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;필드를 하나씩 옮길 때마다 컴파일과 테스트를 실시&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메서드 이동(Move Method)을 실시해서 원본 클래스의 &lt;strong&gt;메서드를 새 클래스로 이동&lt;/strong&gt;&lt;br /&gt;
하급메서드(피 호출 메서드)부터 시작해서 상급 메서드(호출 메서드)에 적용&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메서드 이동을 실시할 때마다 테스트를 실시&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;각 클래스를 다시 검사해서 &lt;strong&gt;인터페이스를 줄임&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;양방향 링크가 있다면 가능하다면 단방향으로 바꿈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;여러 곳에서 &lt;strong&gt;클래스에 접근&lt;/strong&gt;할 수 있게 할지 결정&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;여러 곳에서 접근할 수 있게 할 경우 새 클래스를 참조 객체나 변경불가 값 객체로서 공개할지 여부를 결정&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-2:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    private String _name;
    private String _officeAreaCode;
    private String _officeNumber;

    ...

    public String getTelephoneNumber() {
        return (&amp;quot;(&amp;quot; + _officeAreaCode + &amp;quot;)&amp;quot; + _officeNumber);
    }

    String getOfficeAreaCode() {
        return _officeAreaCode;
    }

    void setOfficeAreaCode(String officeAreaCode) {
        _officeAreaCode = officeAreaCode;
    }

    String getOfficeNumber() {
        return _officeNumber;
    }

    void setOfficeNumber(String officeNumber) {
        _officeNumber = officeNumber;
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;Person&lt;/code&gt; 클래스에서 전화번호 기능을 따로 하나의 클래스로 분리&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    private String _name;
    private TelephoneNumber _officeTelephone = new TelephoneNumber();
    
    ...

    public String getName() {
        return _name;
    }
    
    public String getTelephoneNumber() {
        return _officeTelephone.getTelephoneNumber();
    }

    // 위임메서드
    TelephoneNumber getOfficeTelephone() {
        return _officeTelephone;
    }

    ...

    class TelephoneNumber {
        private String _areaCode;
        private String _number;

        public String getTelephoneNumber() {
            return (&amp;quot;(&amp;quot; + _areaCode + &amp;quot;)&amp;quot; + _number);
        }

        String getAreaCode() {
            return _areaCode;
        }

        void setAreaCode(String areaCode) {
            _areaCode = areaCode;
        }

        String getNumber() {
            return _number;
        }

        void setNumber(String number) {
            _number = number;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;TelephoneNumber&lt;/code&gt;클래스의 공개 정도&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getOfficeTelephone&lt;/code&gt; 위임 메서드를 이용하며 패키지 내에서만 공개&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클래스 공개시 객체 변경에 대처 방식&lt;/strong&gt;
* 어디에서든 공개된 클래스의 객체가 변경될 수 있음을 받아들임
* 어느 주체든 원본 클래스를 거치지 않고는 클래스의 값을 변경하지 못하도록 함
* 클래스를 외부로 전달하기 전에 객체를 복제하여 원 객체가 변경되지 않도록 함&lt;br /&gt;
  → &lt;em&gt;코드를 보는 이들은 값의 변경이 가능한 것으로 착각할 수 있으므로 클라이언트 간의 왜곡 문제가 발생할 수 있음&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;클래스-내용-직접-삽입-inline-class:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;클래스 내용 직접 삽입 (Inline Class)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;클래스에 기능이 너무 적을 경우&lt;br /&gt;
→ &lt;em&gt;그 클래스의 모든 기능을 다른 클래스로 합치고 원본 클래스는 삭제&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-3:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;클래스 내용 직접(Inline Class) 와 클래스 추출(Extract Class)는 반대 개념&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;적용 대상&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클래스의 대부분의 기능이 리팩토링을 통해서 다른 곳으로 옮겨져 클래스가 더이상 &lt;strong&gt;존재할 이유가 없어진 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;방법-3:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;원본 클래스의 &lt;code&gt;public&lt;/code&gt; 메서드를 합칠 클래스에 선언하고 전부 원본 클래스에 위임&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원본 클래스의 메서드 대신 별도의 인터페이스가 알맞다고 판단되면 클래스 내용 직접 삽입을 실시하기 전에 인터페이스 추출(Extract Interface) 기법을 실시&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 클래스를 참조하고 있는 부분들을 합칠 클래스를 참조하도록 수정&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원본 클래스를 &lt;code&gt;private&lt;/code&gt;로 선언하고 패키지 밖에서 참조하고 있는 부분들을 삭제&lt;/li&gt;
&lt;li&gt;컴파일러가 껍데기만 남은 원본 클래스를 참조하고 있는 부분들을 찾아낼 수 있게 원본 클래스명을 변경&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일과 테스트를 실시&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메서드 이동(Move Method)과 필드 이동(Move Field)을 실시해 기능들을 합칠 클래스로 이전&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 클래스를 삭제&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-3:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    private String _name;
    private TelephoneNumber _officeTelephone = new TelephoneNumber();
    ...
    public String getName() {
        return _name;
    }

    public String getTelephoneNumber() {
        return _officeTelephone.getTelephoneNumber();
    }
    
    TelephoneNumber getOfficeTelephone() {
        return _officeTelephone;
    }
    ...
}

public class TelephoneNumber {
    private String _areaCode;
    private String _number;
    ...
    public String getTelephoneNumber() {
        return (&amp;quot;(&amp;quot; + _areaCode + &amp;quot;)&amp;quot; + _number);
    }

    String getAreaCode() {
        return _areaCode;
    }

    void setAreaCode(String arg) {
        _areaCode = arg;
    }

    String getNumber() {
        return _number;
    }

    void setNumber(String arg) {
        _number = arg;
    }
    ...
}

public class Client {
    public static void main() {
        Person martin = new Person();
        martin.getOfficeTelephone().setAreaCode(&amp;quot;781&amp;quot;);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;&lt;br /&gt;
존재할 의미가 없는 &lt;code&gt;TelephoneNumber&lt;/code&gt; 클래스를 &lt;code&gt;Person&lt;/code&gt; 클래스로 병합&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    ...
    String getAreaCode() {
        return _officeTelephone.getAreaCode();
    }

    void setAreaCode(String arg) {
        _officeTelephone.setAreaCode(arg);
    }

    String getNumber() {
        return _officeTelephone.getNumber();
    }

    void setNumber(String arg) {
        _officeTelephone.setNumber(arg);
    }
    ...
}

public class Client {
    public static void main() {
        Person martin = new Person();
        martin.setAreaCode(&amp;quot;781&amp;quot;);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;대리-객체-은폐-hide-delegate:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;대리 객체 은폐 (Hide Delegate)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;클라이언트가 객체의 대리 클래스를 호출할 경우&lt;br /&gt;
→ &lt;em&gt;대리 클래스를 감추는 메서드를 서버에 작성하자&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-4:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;캡슐화란 객체가 시스템의 다른 부분에 대한 정보를 일부분만 알 수 있도록 함&lt;br /&gt;
→ _변경이 일어날 때 전달해야 하는 객체가 줄어들어 변경이 용이_해짐&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;클라이언트 객체에서 서버 객체의 필드 중 하나에 정의된 메서드를 호출할 때 그 클라이언트는 이 대리 객체에 관하여 알아야 함&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;이 대리 객체의 변경이 발생하면 클라이언트도 변경해야 할 가능성이 높아짐&lt;/li&gt;
&lt;li&gt;서버 객체에 대리 객체를 감추는 위임 메서드를 두면 클라이언트 객체에 대리 객체를 숨길 수 있음 → 대리 객체의 변경이 클라이언트에 영향을 미치지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;방법-4:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;대리 객체에 들어 있는 각 메서드를 대상으로 서버에 간단한 위임 메서드를 작성&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;클라이언트를 수정해서 서버를 호출하도록 수정&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;클라이언트 클래스가 서버 클래스와 같은 패키지에 들어 있지 않다면 대리 클래스의 메서드에 대한 접근을 같은 패키지에 든 클래스만 접근할 수 있게 수정하는 것을 고려&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;각 메서드를 수정할 때마다 컴파일과 테스트를 실시&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;대리 객체를 읽고 써야 할 클라이언트가 하나도 남지 않게 되면, 서버에서 대리 객체를 제공하는 읽기/쓰기 메서드를 삭제&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일과 테스트를 실시&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-4:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    Department _department;
    ...
    public Department getDepartment() {
        return _department;
    }

    public void setDepartment(Department arg) {
        _department = arg;
    }
    ...
}

public class Department {
    private String _chargeCode;
    private Person _manager;
    ...
    public Department(Person manager) {
        _manager = manager;
    }

    public Person getManager() {
        return _manager;
    }
    ...
}

// In client
Person manager = john.getDepartment().getManager();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;&lt;br /&gt;
클라이언트에서 대리 객체인 &lt;code&gt;Department&lt;/code&gt; 클래스를 은닉함&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    ...
    // 삭제
    //public Department getDepartment() {
    //    return _department;
    //}

    // 삭제
    //public void setDepartment(Department arg) {
    //    _department = arg;
    //}
    ...

    public Person getManager() {
        return _department.getManager();
    }
}

// In client
Person manager = john.getManager();
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;과잉-중개-메서드-제거-remove-middle-man:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;과잉 중개 메서드 제거 (Remove Middle Man)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;클래스에 자잘한 위임이 너무 많을 경우&lt;br /&gt;
→ &lt;em&gt;대리 객체를 클라이언트가 직접 호출하도록 함&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-5:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;대리 객체 은폐(Hide Delegate) 와 과잉 중개 메서드 제거(Remove Middle Man) 은 반대 개념&lt;/p&gt;

&lt;p&gt;대리 객체의 캡슐화는 많은 장점을 가지지만,&lt;br /&gt;
클라이언트가 대리 객체의 기능을 사용할 때마다 서버에 위임 메서드를 만들어야 하는 단점도 존재&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;적절한 은폐의 정도&lt;/strong&gt;
* 시간을 두고 조금씩 수정해 나감
* 기존에는 적절한 것으로 보이던 캡슐화가 현재는 불필요할 수 있을 수 있으므로 필요할 때마다 보수&lt;/p&gt;

&lt;h3 id=&#34;방법-5:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;대리 객체에 대한 접근 메서드를 작성&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;대리 메서드를 클라이언트가 사용할 때마다 서버에서 메서드를 제거하고 클라이언트에서 호출을 대리 객체에서의 메서드 호출로 교체&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메서드를 수정할 때마다 테스트를 실시&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-5:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    ...
    public Person getManager() {
        return _department.getManager();
    }
    ...
}

// In client
Person manager = john.getManager();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;&lt;br /&gt;
클라이언트에서 대리 객체인 &lt;code&gt;Department&lt;/code&gt; 클래스를 직접 사용할 수 있도록 함&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    ...
    public Department getDepartment() {
        return _department;
    }
    ...
}

// In client
Person manager = john.getDepartment().getManager();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일부 클라이언트에서는 위임 메서드를 그대로 사용하고 일부 클라이언트에서는 대리 객체를 사용할 경우도 있을 수 있으므로&lt;br /&gt;
위임 메서드를 그대로 둬야할 경우도 있음&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;외래-클래스에-메서드-추가-introduce-foreign-method:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;외래 클래스에 메서드 추가 (Introduce Foreign Method)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;사용 중인 서버 클래스에 메서드를 추가해야 하는데 그 클래스를 수정할 수 없을 경우&lt;br /&gt;
→ &lt;em&gt;클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫 번째 인자로 받는 메서드를 작성&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-6:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;원본 클래스의 수정이 불가한 경우에 중복적으로 작성해야 코드&lt;/li&gt;
&lt;li&gt;리팩토링을 실시할 때 새로 만드는 메서드를 외래 메서드로 만들어서 원본 메서드인 서버 메서드에 있어야 하는 것을 드러낼 수 있음&lt;/li&gt;
&lt;li&gt;임시 방편으로 원래 있어야 할 위치로 보내는 것을 목표로 해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;방법-6:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;필요한 기능의 메서드를 클라이언트 클래스 안에 작성&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;메서드 내에서는 클라이언트 클래스의 어떠한 기능에도 접근해서는 안됨&lt;br /&gt;
→ 값이 필요할 때는 매개변수로 전달&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;서버 클래스의 인스턴스를 첫 번째 매개변수로 만듦&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그 메서드에 &amp;lsquo;서버 클래스에 있을 외래 메서드&amp;rsquo; 같은 주석을 작성&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;외래 메서드를 옮길 일이 생겼을 경우 문자열 검색 기능의 활용이 가능&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-6:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Calendar newStart1 = (Calendar)end1.clone();
newStart1.add(Calendar.DAY_OF_MONTH, 1);

Date newStart2 = new Date(end2.getYear(), end2.getMonth(), end2.getDate() + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;리팩토링 목표&lt;/strong&gt;&lt;br /&gt;
중복적으로 발생할 수 있는 날짜 관련 처리를 확장하는 메서드를 생성&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Calendar newStart1 = getNextDay(end1);
Date newStart2 = getNextDay(end2);
...
private static Calendar getNextDay(Calendar arg) {
    Calendar newStart = (Calendar)arg.clone();
    newStart.add(Calendar.DAY_OF_MONTH, 1);
    return newStart;
}

private static Date getNextDay(Date arg) {
    Date newStart = new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
    return newStart;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;국소적-상속확장-클래스-사용-introduce-local-extension:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;국소적 상속확장 클래스 사용 (Introduce Local Extension)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;사용 중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐&lt;br /&gt;
→ &lt;em&gt;새 클래스를 작성하고 그 안에 필요한 여러개의 메서드를 작성&lt;/em&gt;&lt;br /&gt;
→ &lt;em&gt;이 상속확장 클래스를 원본 클래스의 하위클래스나 래퍼클래스로 만듦&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;동기-7:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;동기&lt;/h3&gt;

&lt;p&gt;원본 클래스의 수정이 불가능할 때 필요한 메서드가 한 두개라면 외래 클래스에 메서드 추가(Introduce Foreign Method) 기법을 실시&lt;br /&gt;
하지만 그 수가 세 개 이상이라면 메서드를 적당한 곳에 모아 두어야 함&lt;/p&gt;

&lt;p&gt;해결을 위한 방법: &lt;strong&gt;하위클래스화(subclassing) + 래퍼화(wrapping) → 국소적 상속확장 클래스(Local Extension)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;국소적 상속확장 클래스는 별도의 클래스이지만 원본 클래스의 하위타입이므로, 원본 클래스의 모든 기능을 사용할 수 있으면서 추가 기능도 사용할 수 있게 됨 → 원본 클래스를 사용하는 게 아니라 국소 상속확장 클래스를 사용하게 됨&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사용하면 얻을 수 있는 이점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메서드와 데이터가 체계적으로 묶여야 한다는 원칙이 지켜짐&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하위클래스(subclass)&lt;/strong&gt;
* 작업량 줄어듬
* 객체 생성 시점에서 하위클래스의 인스턴스로 만들어야 함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;래퍼클래스(wrapper)&lt;/strong&gt;
* 원본클래스를 래핑하고 있음
* 래퍼클래스의 변경이 원본클래스에 반영되고, 그 반대의 경우도 반영됨&lt;/p&gt;

&lt;h3 id=&#34;방법-7:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;방법&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;상속확장 클래스를 작성한 후 원본 클래스의 하위클래스나 래퍼클래스로 만듦&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;상속확장 클래스에 변환 생성자를 만듦&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;생성자에서 원본클래스를 인자로 받음&lt;/li&gt;
&lt;li&gt;하위클래스: 적절한 상위클래스 생성자를 호출&lt;/li&gt;
&lt;li&gt;래퍼클래스: 대리 필드에 그 인자를 할당&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;상속확장 클래스에 새 기능을 추가&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;필요한 위치마다 원본 클래스를 상속확장 클래스로 수정&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원본 클래스 용으로 정의된 외래 메서드를 전부 상속확장 클래스로 옮김&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;예제-7:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 하위 클래스
class MfDateSub extends Date {
    public MfDateSub getNextDay()...
    public int dayOfYear()...
}

// 래퍼 클래스
class MfDateWrap {
    private Date _original;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;c-의-확장-메서드:7108f0e03167c3fe7f303520cba05d2e&#34;&gt;C# 의 확장 메서드&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;C# 의 확장 메서드는 원본 클래스의 파생(확장,하위)클래스를 만들지 않고 메서드를 추가하는 방법&lt;br /&gt;
→ &lt;em&gt;확장 메서드는 특수한 정적 메서드 이지만 원본 클래스의 인스턴스 메서드인 것처럼 호출됨&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;정적 클래스 내에 정의해야 함&lt;/li&gt;
&lt;li&gt;첫 번째 매개변수는 &lt;code&gt;this&lt;/code&gt; 키워드를 포함한 확장하고자 하는 원본 형식을 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class DateTimeExtensions
{
    public static DateTime NextDay(this DateTime date)
    {
        return date.AddDays(1);
    }

    public static DateTime PreviousDay(this DateTime date)
    {
        return date.AddDays(-1);
    }
}

[TestClass]
public class DateTimeExtensionsUnitTest
{
    [TestMethod]
    public void NextDayTest()
    {
        // Arrange
        DateTime date1 = new DateTime(2015, 2, 28);
        DateTime date2 = new DateTime(2016, 2, 28);

        // Act
        DateTime next1 = date1.NextDay();
        DateTime next2 = date2.NextDay();

        // Assert
        Assert.AreEqual&amp;lt;int&amp;gt;(1, next1.Day);
        Assert.AreEqual&amp;lt;int&amp;gt;(29, next2.Day);
    }

    [TestMethod]
    public void PreviousTest()
    {
        // Arrange
        DateTime date1 = new DateTime(2015, 3, 1);
        DateTime date2 = new DateTime(2016, 3, 1);

        // Act
        DateTime prev1 = date1.PreviousDay();
        DateTime prev2 = date2.PreviousDay();

        // Assert
        Assert.AreEqual&amp;lt;int&amp;gt;(28, prev1.Day);
        Assert.AreEqual&amp;lt;int&amp;gt;(29, prev2.Day);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>메서드 정리</title>
      <link>http://kwsstudy.github.io/post/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC/</link>
      <pubDate>Sun, 22 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/%EB%A9%94%EC%84%9C%EB%93%9C%EC%A0%95%EB%A6%AC.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/2.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/3.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/4.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/5.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/6.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/7.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/8.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/9.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/11.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/12.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/13.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/14.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/15.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/16.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/17.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/18.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/19.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/20.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/21.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/22.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/Refactoring/master/src/com/kws/MethodClean/6%EC%9E%A5%EC%BA%A1%EC%B3%90/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>리팩토링 기법 카탈로그</title>
      <link>http://kwsstudy.github.io/post/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EA%B8%B0%EB%B2%95-%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8/</link>
      <pubDate>Sat, 14 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EA%B8%B0%EB%B2%95-%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8/</guid>
      <description>

&lt;h3 id=&#34;리팩토링-기법-카탈로그에-대해:cf48b4a86ee1ae5b9a9baa209941d994&#34;&gt;리팩토링 기법 카탈로그에 대해&lt;/h3&gt;

&lt;h2 id=&#34;1-각-리팩토링-기법-절의-구성:cf48b4a86ee1ae5b9a9baa209941d994&#34;&gt;1. 각 리팩토링 기법 절의 구성&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;카탈로그 부분의 각 리팩토링 기법은 다음과 같은 5개의 하위 절로 구성했다.

&lt;ul&gt;
&lt;li&gt;이름 : 각종 리팩토링 기법을 구별하기 위한 필수적인 요소, 카탈로그의 각 절 제목으로도 사용했다.&lt;/li&gt;
&lt;li&gt;요약 : 기법의 적용 시점과 목적을 설명. 이부분을 보면 자신에게 필요한 리팩토링 기법을 더 빨리 찾을 수 있다.&lt;/li&gt;
&lt;li&gt;동기 : 기법을 실시하는 이유와 실시하지 말아야 할 경우를 설명한다.&lt;/li&gt;
&lt;li&gt;방법 : 기법을 수행하는 절차를 단계적으로 간단명료하게 설명한다.&lt;/li&gt;
&lt;li&gt;예제 : 기법의 원리를 이해하도록 간단한 리팩토링 사례를 보여준다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-참조검색:cf48b4a86ee1ae5b9a9baa209941d994&#34;&gt;2. 참조검색&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;대다수의 리팩토링 작업에서는 메서드, 인스턴스 값, 클래스 등으로의 참조 부분을 전부 찾아야한다.&lt;/li&gt;
&lt;li&gt;이러한 참조 검색에는 적합한 텍스트 검색 기능을 활용(이당시에는 마땅한 이클립스 같은 툴이 없었던거같다)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-리팩토링-기법의-성숙도:cf48b4a86ee1ae5b9a9baa209941d994&#34;&gt;3. 리팩토링 기법의 성숙도&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;리팩토링의 기본 기법인 &amp;lsquo;사소한 단계쩍 수정과 잦은 테스트&amp;rsquo;는 스몰토크 동호회를 중심으로 수년간 검증&lt;/li&gt;
&lt;li&gt;이 책에 나와있는 내용도 저자가 사용한 리팩토링에 관해 메모해둔 내용&lt;/li&gt;
&lt;li&gt;패턴과 리팩토링은 자연스럽게 관련되어 있다. 패턴은 목표 지향점이고, 리팩토링은 다른상태에서 그 지향점까지 도달하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>코드의 구린내</title>
      <link>http://kwsstudy.github.io/post/%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B5%AC%EB%A6%B0%EB%82%B4/</link>
      <pubDate>Sat, 14 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B5%AC%EB%A6%B0%EB%82%B4/</guid>
      <description>

&lt;h3 id=&#34;03-코드의-구린내:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;03. 코드의 구린내&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;구린게 있으면 그 부분을 바로 잡으세요.&lt;/li&gt;
&lt;li&gt;리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링 기법을 적용하는 방법만큼 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-중복코드:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;1. 중복코드&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;구린내의 제왕 &lt;strong&gt;중복코드&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;한 클래스의 두 메서드 안에 같은 코드가 들어있는경우 -&amp;gt; &lt;strong&gt;메서드 추출 기법&lt;/strong&gt;을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서          드를 두 곳에서 호출&lt;/li&gt;
&lt;li&gt;수퍼클래스의 두 하위 클래스에 같은 코드가 들어 있는 경우 -&amp;gt; &lt;strong&gt;메서드 추출 기법&lt;/strong&gt;을 적용해서 중복을 없앤 후 &lt;strong&gt;메서드 상향 기법&lt;/strong&gt;을 적용하면   된다.&lt;/li&gt;
&lt;li&gt;위 상황에 코드가 똑같지 않고 비슷하다면 &lt;strong&gt;메서드 추출기법&lt;/strong&gt;을 적용해서 같은 부분과 다른 부분을 분리해야 한다. 그런 다음 경우에 따라 &lt;strong&gt;템플릿 메서드 형성 기법&lt;/strong&gt;을 적용해야 할 수도있다.&lt;/li&gt;
&lt;li&gt;두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해서 &lt;strong&gt;알고리즘 전환 기법&lt;/strong&gt;을 적용하면 된다.&lt;/li&gt;
&lt;li&gt;중복 코드가 메서드 가운데에 있다면 주변 &lt;strong&gt;메서드 추출&lt;/strong&gt;을 적용하면된다.&lt;/li&gt;
&lt;li&gt;서로 상관 없는 두 클래스 안에 중복코드가 있을 때 -&amp;gt; 한 클래스 안의 중복 코드를 &lt;strong&gt;클래스 추출&lt;/strong&gt; 이나 모듈 추출 을 적용해 제 3의
클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다. 또는 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른클래스에서 그 메서드를 호출하거나 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법이 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-장황한-메서드:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;2. 장황한 메서드&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.&lt;/li&gt;
&lt;li&gt;짧은 메서드를 이해하기 쉽게하려면 메서드 명을 잘 정해야한다.
메섣의 기능을 한눈에 알 수 있는 메서드명을 사용하면 그 메서드안의 코드를 분석하지 않아도된다.&lt;/li&gt;
&lt;li&gt;메서드 호출이 원래 코드보다 길어지는 한이 있어도, 메서드 명은 그 코드의 의도를 잘 반영하는 것으로 정해야한다.&lt;/li&gt;
&lt;li&gt;메서드명은 기능 수행 방식이 아니라 목적(즉, 기능자체)을 나타내는 이름으로 정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메서드 추출기법&lt;/strong&gt;을 적용한다.&lt;/li&gt;
&lt;li&gt;코드를 여러 덩어리로 분리하려면?

&lt;ul&gt;
&lt;li&gt;주석을 찾는 것 -&amp;gt; 기능 설명이 주석으로 처리된 코드 구간을 메서드로 만들면 된다. (긴 메서드에서 기능 설명이 주석으로 되어있는 부분)&lt;/li&gt;
&lt;li&gt;조건문과 루프도 역시 메서드로 추출&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-방대한-클래스:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;3. 방대한 클래스&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어있다.
클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-과다한-매개변수:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;4. 과다한 매개변수&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편, 더많은 데이터가 필요해질 때마다 계속 수정해야 한다&lt;/li&gt;
&lt;li&gt;즉 매개변수는 객체를 넘기도록 한다. 객체를 넘김으로써 위 문제들이 해결&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-수정의-산발:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;5. 수정의 산발&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다.&lt;/li&gt;
&lt;li&gt;하나의 클래스를 여러 개의 변형 객체로 분리하는것이 좋다.
그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-기능의-산재:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;6. 기능의 산재&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;하나의 수정으로 여러 클래스가 바뀌게 되는 문제&lt;/li&gt;
&lt;li&gt;수정할 부분들을 전부 하나의 클래스 안에 넣어줘야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-잘못된-소속:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;7 .잘못된 소속&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;메서드가 자신이 속해있는 클래스보다 다른 클래스에서 더 호출이 이루어질 경우 해당 메서드를 더 접근이 많은 클래스로 옮겨줘야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-데이터-뭉치:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;8. 데이터 뭉치&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;두 클래스에 들어 있는 인스턴스 변수나 여러 메서드 시그너처(메서드명과 인수들 목록을 메서드 시그너처 라고 부릅니다.)에 들어있는
매개변수 처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려있는 경우&lt;/li&gt;
&lt;li&gt;이렇게 몰려있는 데이터 뭉치는 객체로 만들어야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-강박적-기본-타입-사용:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;9. 강박적 기본 타입 사용&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;관련된 데이터를 묶지 못하고 흩어놓게 되면, 각각의 데이터에 대한 정보를 외부에 공개해야한다.&lt;/li&gt;
&lt;li&gt;함수를 만들때도 각각의 데이터를 파라미터로 넘겨주어야 하기에 파라미터의 갯수가 늘어나게 된다.&lt;/li&gt;
&lt;li&gt;기본형만 사용할 바에는 객체를 만들어서(구조화)해서 사용해라&lt;/li&gt;
&lt;li&gt;이때는 각각의 관련된 데이터를 하나의 구조체로 묶어 주어야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;10-switch-문:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;10. switch 문&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;switch 문의 단점은 반드시 중복이 생긴다는 점이다.
동일한 switch가 다른 곳에서 또 쓰일가능성이 크다&lt;/li&gt;
&lt;li&gt;switch 문에 새 코드행을 추가하려면 그렇게 여기저기에 존재하는 switch 문을 전부 찾아서 수정해야한다.&lt;/li&gt;
&lt;li&gt;이 문제를 해결할수 있는 방법은 다형성 즉 재정의를 이용하는 것이다.&lt;/li&gt;
&lt;li&gt;switch 문을 메서드 추출로 빼낸 후 메서드 이동을 실시해서 그 메서드를 재정의해야 할 클래스에 옮겨 넣으면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;11-평행-상속-계층:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;11. 평행 상속 계층&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위 클래스도 만들어야 한다.&lt;/li&gt;
&lt;li&gt;중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속계층의 인스턴스를 참조하게 만들면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-직무유기-클래스:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;12. 직무유기 클래스&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다.&lt;/li&gt;
&lt;li&gt;비용만큼의 기능을 수행하지 못하는 비효율적인 클래스는 삭제해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;13-막연한-범용-코드:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;13. 막연한 범용 코드&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;메서드나 클래스가 오직 테스트 케이스에만 사용된다면 구린내를 풍기는 유력한 용의자로 막연한 범용코드를 지목할 수 있다.
이러한 메서드나 클래스를 발견하면 그것과 그것을 실행하는 테스트 케이스는 삭제하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;14-임시-필드:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;14. 임시 필드&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다.&lt;/li&gt;
&lt;li&gt;이러한 떠돌이 해당 변수들을 사용하는 class를 생성한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;15-메시지-체인:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;15. 메시지 체인&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;메시지 체인?

&lt;ul&gt;
&lt;li&gt;클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고 &amp;hellip;. 연쇄적으로 요청이 발생하는 문제점&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;16-과잉-중개-메서드:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;16. 과잉 중개 메서드&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;어떤 클래스의 인터페이스를 보니 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있을경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;17-지나친-관여:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;17. 지나친 관여&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;클래스 끼리 관계가 지나치게 밀접한 나머지 서로의 private를 알아내느라 과도한 시간낭비&lt;/li&gt;
&lt;li&gt;서로 지나지게 친밀한 클래스는 메서드 이동과 필드 이동으로 떼어 낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;18-인터페이스가-다른-대용-클래스:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;18. 인터페이스가 다른 대용 클래스&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;기능은 같은데 시그너처가 다른 메서드에는 메서드명 변경을 실시해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;19-미흡한-라이브러리-클래스:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;19. 미흡한 라이브러리 클래스&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;라이브러리 클래스에 넣어야 할 메서드가 두 개 뿐이라면 외래 클래스에 메서드 추가 기법을, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기       법을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;20-데이터-클래스:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;20. 데이터 클래스&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;데이터 클래스(domain)는 필드 캡슐화기법을 실시해야한다&lt;/li&gt;
&lt;li&gt;변경되지 않아야 하는 필드에는 쓰기 메서드 제거를 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;21-방치된-상속물:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;21. 방치된 상속물&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;하위클래스가 부모클래스에게 상속받은 메서드나 데이터가 하위클래스에서 더이상 쓰이지 않거나 필요 없게 되었을때.&lt;/li&gt;
&lt;li&gt;위 문제의 원인은 잘못된 계층구조&lt;/li&gt;
&lt;li&gt;새 대등 클래스를 작서하고 메서드 하향과 필드하향을 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;22-불필요한-주석:091595a4713834b8fdd2a48e33d8d67b&#34;&gt;22. 불필요한 주석&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어보자.&lt;/li&gt;
&lt;li&gt;주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다.&lt;/li&gt;
&lt;li&gt;어떤 코드를 넣은 이유를 메모해 놓을 경우에도 주석을 넣는 것이 적절하다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>테스트작성</title>
      <link>http://kwsstudy.github.io/post/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1/</link>
      <pubDate>Sat, 14 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1/</guid>
      <description>

&lt;h3 id=&#34;04-테스트-작성:3a266575c8c9dd1ccaba733e70d3c7a6&#34;&gt;04 테스트 작성&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;리팩토링을 실시하기 위한 필수 전제조건은 반드시 견고한 테스트를 해야한다.&lt;/li&gt;
&lt;li&gt;적절한 테스트를 작성하면 설령 리팩토링을 하지않더라도 프로그래밍 속도가 월등히 왜 빨라지는 가에 대해서 설명&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-자가-테스트-코드의-가치:3a266575c8c9dd1ccaba733e70d3c7a6&#34;&gt;1. 자가 테스트 코드의 가치&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;버그를 찾는 데 시간을 많이 소요하는 프로그래머들이 존재&lt;/li&gt;
&lt;li&gt;모든 테스트를 완전히 자동화하고 결과를 자체적으로 검사하게 하자.&lt;/li&gt;
&lt;li&gt;테스트 스위트(하나의 테스트)는 버그를 찾는 시간을 획기적으로 줄여주는 강력한 버그 감지 도구이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-junit-테스트-프레임-워크:3a266575c8c9dd1ccaba733e70d3c7a6&#34;&gt;2. JUnit 테스트 프레임 워크&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;예제 소스&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-단위-테스트와-기능-테스트:3a266575c8c9dd1ccaba733e70d3c7a6&#34;&gt;3. 단위 테스트와 기능 테스트&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;단위 테스트(Unit Test) -&amp;gt; 부분적인 단위만 테스트 한다. 한정적이다&lt;/li&gt;
&lt;li&gt;junit 의 경우 단위테스트용 도구이다&lt;/li&gt;
&lt;li&gt;기능 테스트(Functional Test): 소프트웨어 전체가 제대로 동작하는 지 확인하기 위해 작성한다.&lt;/li&gt;
&lt;li&gt;보통 전체 시스템을 하나의 블랙박스처럼 취급한다. GUI를 통해 테스트를 하고 특정 입력에 대해서 데이터가 어떻게 변하는 지를 본다.&lt;/li&gt;
&lt;li&gt;버그 발견 시 코드를 수정해야 하고 버그를 볼수 있게 표시하는 단위테스트를 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-테스트-추가:3a266575c8c9dd1ccaba733e70d3c7a6&#34;&gt;4. 테스트 추가&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;완벽한 테스트를 작성하려다 아예 테스트를 포기하느니, 차라리 불완전한 테스트를 작성해 실행하는 편이 낫다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리팩토링 개론</title>
      <link>http://kwsstudy.github.io/post/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EA%B0%9C%EB%A1%A0/</link>
      <pubDate>Sun, 08 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EA%B0%9C%EB%A1%A0/</guid>
      <description>

&lt;hr /&gt;

&lt;h5 id=&#34;팩토링은-무엇인가:0f31dad7fb76a8f1e282373ad2f971f1&#34;&gt;팩토링은 무엇인가&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;(명사) 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 방법&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(동사) 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;강조할 내용&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리팩토링의 목적은 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리팩토링은 겉으로 드러나는 소프트웨어 기능에 영향을 주지 않는다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;리팩토링은-왜-해야-하나:0f31dad7fb76a8f1e282373ad2f971f1&#34;&gt;리팩토링은 왜 해야 하나&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;소프트웨어 설계가 개선되기 되니까&lt;/li&gt;
&lt;li&gt;소프트웨어를 이해하기가 더 쉬워지기 되니까&lt;/li&gt;
&lt;li&gt;버그를 찾기가 쉬워지니까&lt;/li&gt;
&lt;li&gt;프로그래밍 속도가 빨라지니까&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;리팩토링은-어떨-때-필요한가:0f31dad7fb76a8f1e282373ad2f971f1&#34;&gt;리팩토링은 어떨 때 필요한가&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;같은 작업의 삼진아웃 때

&lt;ul&gt;
&lt;li&gt;비슷한 작업을 할 때 두번까진 그냥하고 세번째 하게 되면 리팩토링을 실시하는 것이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;기능을 추가할 때&lt;/li&gt;
&lt;li&gt;버그를 수정할 때&lt;/li&gt;
&lt;li&gt;코드를 검수할 때&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;리팩토링의-효용성-켄트-벡:0f31dad7fb76a8f1e282373ad2f971f1&#34;&gt;리팩토링의 효용성 (_켄트 벡)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;프로그램은 다음 4가지 상황일 때 수정하기 힘들어진다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;코드를 알아보기 힘들 때&lt;/li&gt;
&lt;li&gt;중복된 로직이 들어 있을 때&lt;/li&gt;
&lt;li&gt;추가 기능을 넣어야 해서 실행 중인 코드를 변경해야 할 때&lt;/li&gt;
&lt;li&gt;조건문 구조가 복잡할 때&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그러므로 프로그램은 코드를 알아보기 쉽고, 모든 로직이 한 곳에 있으며, 기존 기능을 건드릴 필요 없이 조건문 구조가 최대한 간결하게 끔 작성해야 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리팩토링은 실행 중인 프로그램의 기능을 바꾸는 작업이 아니고 신속한 개발 공정을 가능하게 하는 이런 성질을 가중하면서 가치를 높이는 일이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;리팩토링-관련-문제들:0f31dad7fb76a8f1e282373ad2f971f1&#34;&gt;리팩토링 관련 문제들&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;데이터베이스&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;데이터베이스 스키마를 수정하면 데이터도 이전해야 하는데, 이것은 시간도 오래 걸릴 뿐 아니라 위험성도 높다. 이 문제를 해결하기 위해 객체 모델과 데이터베이스 모델 사이에 별도의 소프트웨어 계층을 두는 방법이 있다. 이렇게 하면 두 모델에 생긴 변경 사항을 따로 유지할 수 있어서 한 모델을 수정할 때 다른 모델은 수정할 필요 없이 그저 중개 계층만 수정하면 된다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;인터페이스변경&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;객체의 중대한 장점중 하나는 인터페이스를 건드리지 않고 내부의 구현 코드를 수정할 수 있다는 점이다. 리팩토링에서 불안한 점은 상당수의 리팩토링이 인터페이스를 건드린다는 것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그렇다면 배포 인터페이스를 수정하는 리팩토링 기법들을 실시할 때는 어떻게 해야 할까?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;간단히 말하면 어떤 리팩토링 기법이 배포 인터페이스를 건드릴 경우 개발자는 적어도 그 인터페이스를 사용하는 부분이 그 인터페이스 변경에 맞춰 수정되기 전까지는 기존 인터페이스와 새 인터페이스를 모두 그대로 유지시켜야 한다. 그리고 deprecation 같은 타입을 작성해서 호출자에게 그 코드를 사용하지 말아야 함을 알려야 한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리팩토링하면 안되는 상황&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;처음부터 새로 작성하는게 리팩토링보다 더 쉬울 경우&lt;/li&gt;
&lt;li&gt;코드가 돌아가지 않는 경우&lt;/li&gt;
&lt;li&gt;납기가 임박했을 때&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;리팩토링과-성능:0f31dad7fb76a8f1e282373ad2f971f1&#34;&gt;리팩토링과 성능&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;많은 이들이 리팩토링으로 인해 프로그램 성능이 어떤 영향을 받는지에 관심이 많다. 소프트웨어를 이해하기 쉽게 만들려면 수정할 일이 많은데 그런 수정으로 프로그램이 느려질 수도 있다. 이건 아주 큰 문제다. 리팩토링을 실시하면 분명 소프트웨어는 더 느려지지만, 소프트웨어 성능을 더 간단히 조절할 수 있다. 소프트웨어 성능을 올리려면 먼저 소프트웨어를 튜닝가능하게 만들어 놓고 나중에 충분한 속도가 나오게 튜닝하는 것이다. 이것은 철저한 실시간 환경을 제외한 모든 환경에 적용된다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>맛보기 예제</title>
      <link>http://kwsstudy.github.io/post/%EB%A7%9B%EB%B3%B4%EA%B8%B0-%EC%98%88%EC%A0%9C/</link>
      <pubDate>Sun, 08 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%A7%9B%EB%B3%B4%EA%B8%B0-%EC%98%88%EC%A0%9C/</guid>
      <description>

&lt;h4 id=&#34;원래의-프로그램:30755030f144d3278f749327f4151410&#34;&gt;원래의 프로그램&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;맛보기 예제는 단순히 비디오 대여점에서 고객의 대여료 내역을 계산하고 출력하는 간단한 프로그램이다. 이 프로그램은 고객이 대여한 비디오와 대여기간을 표시한 후, 비디오 종류와 대여 기간을 토대로 대여료를 계산한다. 비디오 종류에는 일반물, 아동물, 최신물 세종류다. 대여료 계산과 더불어 내역을 바탕으로 적립 포인트도 계산되는데, 이 포인트는 비디오가 최신물인지 아닌지에 따라 달라진다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Movie클래스&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Movie {
	public static final int CHILDRENS = 2;
	public static final int REGULAR = 0;
	public static final int NEW_RELEASE = 1;
	private String _title;
	private int _priceCode;
	
	public Movie(String title, int priceCode){
		_title = title;
		_priceCode = priceCode;
	}
	
	public int getPriceCode() {
		return _priceCode;
	}
	
	public void setPriceCode(int arg) {
		_priceCode = arg;
	}
	
	public String getTitle() {
		return _title;
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Rental 클래스
```java&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public class Rental {
	private Movie _movie;
	private int _daysRented;&lt;/p&gt;

&lt;p&gt;	public Rental(Movie movie, int daysRented) {
		_movie = movie;
		_daysRented = daysRented;
	}&lt;/p&gt;

&lt;p&gt;	public int getDaysRented() {
		return _daysRented;
	}&lt;/p&gt;

&lt;p&gt;	public Movie getMovie() {
		return _movie;
	}
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
* Customer 클래스
```java
public class Customer {
	private String _name;
	private Vector _rentals = new Vector();
	
	public Customer(String name) {
		_name = name;
	}
	
	public void addRental(Rental arg) {
		_rentals.addElement(arg);
	}
	
	public String getName() {
		return _name;
	}
	
	//리팩토링이 필요한 핵심 메서드
	//너무 많은 기능을 가지고 있다
	public String statement() {
		double totalAmount = 0;
		int frequentRenterPoints = 0;
		Enumeration&amp;lt;Rental&amp;gt; rentals = _rentals.elements();
		String result = getName() + &amp;quot; 고객님의 대여 기록 \n&amp;quot;;
		
		while(rentals.hasMoreElements()) {
			double thisAmount = 0;
			Rental each = (Rental) rentals.nextElement();
			
			//비디오 종류별 대여로 계산 
			switch (each.getMovie().getPriceCode()) {
			case Movie.REGULAR:
				thisAmount += 2;
				if(each.getDaysRented() &amp;gt; 2) 
					thisAmount += (each.getDaysRented() - 2) * 1.5;
				break;
			case Movie.NEW_RELEASE:	
				thisAmount += each.getDaysRented() * 3;
				break;	
			case Movie.CHILDRENS:
				thisAmount += 1.5;
				if(each.getDaysRented() &amp;gt; 3)
					thisAmount += (each.getDaysRented() - 3) * 1.5;
				break;	
			}
			
			//적립 포인트 1포인트 증
			frequentRenterPoints ++;
			
			//최신물을 이틀 이상 대여하면 보너스 포인트 지급 
			if((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;amp;&amp;amp; each.getDaysRented() &amp;gt; 1)
				frequentRenterPoints++;
			
			//대여하는 비디오 정보와 대여로를 출
			result += &amp;quot;\t&amp;quot; + each.getMovie().getTitle() + &amp;quot;\t&amp;quot; + String.valueOf(thisAmount) + &amp;quot;\n&amp;quot;;
			
			//현재까지 누적된 총 대여료
			totalAmount += thisAmount;
		}
		
		//footer
		result += &amp;quot;누적 대여료 : &amp;quot; + String.valueOf(totalAmount) + &amp;quot;\n&amp;quot;;
		result += &amp;quot;적립 포인트 : &amp;quot; + String.valueOf(frequentRenterPoints);
		return result;
	}
	
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;맛보기-프로그램설명:30755030f144d3278f749327f4151410&#34;&gt;맛보기 프로그램설명&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;statement 메서드에서 지나치게 많은 기능이 들어 있는데 대부분의 기능은 다른 두 클래스에 들어가야 하는 기능이다.&lt;/li&gt;
&lt;li&gt;수정이 없을 경우면 상관이 없지만 수정이 필요한 경우 설계가 조잡하여 수정이 어렵다. 수정이 어려우면 버그가 생길 확률이 높다.&lt;/li&gt;
&lt;li&gt;htmlStatement메서드를 추가해야한다. 그렇게 되면 기능을 수정할 때마다 두 메서드를 똑같이 수정해야 한다.&lt;/li&gt;
&lt;li&gt;위의 프로그램은 당장은 문제가 없지만 이러한 수정 사항이 생겼을 경우 수정하기가 힘들다. 그렇기 때문에 리팩토링을 해야할 시점이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;리팩토링-첫-단계:30755030f144d3278f749327f4151410&#34;&gt;리팩토링 첫 단계&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;리팩토링의 첫단계는 신뢰도 높은 테스트를 작성하는 것이다. 아무리 체계적인 리팩토링 공식을 이용해 버그가 생길 수 있는 대부분의 원인을 방지하더라도, 인간인 이상 실 수할 수 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;statement-메서드-분해와-기능-재분배:30755030f144d3278f749327f4151410&#34;&gt;statement 메서드 분해와 기능 재분배&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;긴 메서드를 분해해서 각 부분을 알맞은 클래스로 옮겨야 한다.&lt;/li&gt;
&lt;li&gt;이것은 중복 코드를 줄이고 htmlStatement를 간편하게 작성하기 위함이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;우선-논리적-코드-뭉치를-찾아-메서드-추출-기법-extract-method-142p-을-적용한다:30755030f144d3278f749327f4151410&#34;&gt;우선 논리적 코드 뭉치를 찾아 메서드 추출 기법(Extract Method 142p)을 적용한다.&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;여기서 확실히 분리할 부분은 switch문이다. amountFor메서드로 추출한다.&lt;/li&gt;
&lt;li&gt;추출후 바람직하지 않은 변수명을 수정한다. 변수명을 수정하면 무슨 기능을 하는지 분명히 드러낼 수 있기 때문에 아주 중요하다.&lt;/li&gt;
&lt;li&gt;변수명 수정이 끝났으니 컴파일과 테스트를 실시해서 에러가 없는지 확인한다. 리팩토링은 단계별로 테스트를 하면서 진행해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;대여료-계산-메서드-옮기기:30755030f144d3278f749327f4151410&#34;&gt;대여료 계산 메서드 옮기기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;amountFor메서드를 보면 Rental 클래스의 정보를 이용하고 정작 자신이 속한 Customer 클래스의 정보는 이용하지 않는다.&lt;/li&gt;
&lt;li&gt;amountFor메서드가 잘못된 객체에 들어 있는 건 아닌지 의심을 해야한다. 메서드는 대체로 자신이 사용하는 데이터와 같은 객체에 들어 있어야 한다. 이 메서드는 Rental 클래스로 옮겨야 한다. 이 작업은 메서드 이동 (Move Method 178p) 기법을 실시하면 된다.&lt;/li&gt;
&lt;li&gt;Rental 클래스에 getCharge란 메서드로 옮긴 후 테스트를 실행하고 문제가 없는지 확인한다.&lt;/li&gt;
&lt;li&gt;thisAmount변수의 불필요한 중복. 따라서 임시변수를 메서드 호출로 전환(Replace Temp with Query 153p)기법을 사용해서 this 변수를 삭제한다. 임시변수가 많으면 불필요하게 많은 매개변수를 전달하게 되는 문제가 생긴다. 그리고 임시변수의 용도는 잊기 쉽다.&lt;/li&gt;
&lt;li&gt;기존 메서드 참조 부분을 전부 찾아서 새 메서드 참조로 수정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;적립-포인트-계산을-메서드로-빼기:30755030f144d3278f749327f4151410&#34;&gt;적립 포인트 계산을 메서드로 빼기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;statement 메서드 안에서만 유효한 지역변수의 쓰임을 살펴보면 each가 사용되었는데 이것은 매개변수로 전달이 가능하다. 그리고 frequentRenterPoints가 임시변수로 사용되었는데 이미 값이 들어있다. 하지만 추출한 메서드안의 코드는 이 값을 읽을 수 없으나 추가로 대입문을 작성하면 임시변수를 매개변수로 전달할 필요는 없다.&lt;/li&gt;
&lt;li&gt;getFrequentRenterPoints 메서드로 만들고 rental 클래스로 옮긴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;임시변수-없애기:30755030f144d3278f749327f4151410&#34;&gt;임시변수 없애기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;임시변수는 문제가 생길 수 있다. 임시변수는 자체 루틴안에서만 효력이 있다 보니, 점점 더 ㅁ낳은 임시변수를 사용하게 되어 코드가 복잡해지기 쉽다. 현재 임시변수는 두 개 있으며, 두 변수는 해당 고객에 첨가된 대여료를 이용해 총 대여료를 계산할 때 사용된다. 총 대여로는 아스키 코드 내역과 HTML 내역 두 곳에 필요하다. 임시변수를 메서드 호출로 전환(Replace Temp with Query 153p)기법을 실시해서 totalAmount와 frequent RentalPoints 변수를 질의 메서드로 고치는 것을 선호한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private double getTotalCharge() {
		double result = 0;
		Iterator&amp;lt;Rental&amp;gt; rentals = _rentals.iterator();
		
		while (rentals.hasNext()) {
			Rental each = (Rental) rentals.next();
			result += each.getCharge();
		}
		return result;
	}

	private int getTotalFrequentRenterPoints() {
		int result = 0;
		
		Iterator&amp;lt;Rental&amp;gt; rentals = _rentals.iterator();
		
		while (rentals.hasNext()) {
			Rental each = (Rental) rentals.next();
			result += each.getFrequentRenterPoints();
		}
		return result;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;대개 리팩토링은 코드 양이 줄게 마련인데 위의 리팩토링 기법은 코드양이 줄지 않고 늘었다. 이유는 java에서는 루프안에서 합산하는 데 많은 명령이 필요하기 때문이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;또하나의 문제점은 성능이다. 수정 전 코드는 while문 루프 1회만 실행되었는데 수정 후 코드는 3회나 실행된다. 오랜 시간이 걸리는 while 문으로 인해 성능이 저하된다. 많은 프로그래머들은 이런 이유 때문에 이 리팩토링을 하지 않으려 하지만, 항상 다양한 경우의 수를 생각하자. while문 리팩토링에 지레 겁먹을 필요는 없다. while 문은 최적화 단계에서 걱정해도 늦지 않다. 최적화 단계가 성능 해결의 적기이며 효과적인 최적화를 위한 더 많은 선택의 여지가 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이 메서드 호출들은 이제 Customer 클래스 안 어디서나 사용할 수 있다. 이제 시스템의 다른 부분에 이 정보가 필요하다면 이 메서드 호출들을 클래스의 public 인터페이스에 간단히 추가하면 된다. 이런 질의 메서드 호출 방식을 사용하지 않으면, 대여료 정보를 알아내고 루프안에서 계산하는 코드를 여러 다른 메서드에 넣어야 할 것이다. 복잡한 시스템에서는 그렇게 하면 작성할 코드도 많아지고 그에 따라 유지보수도 힘들어진다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-htmlStatement 메서드를 추가하다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String htmlStatement() {
		Iterator&amp;lt;Rental&amp;gt; rentals = _rentals.iterator();
		String result = &amp;quot;&amp;lt;H1&amp;gt;&amp;lt;EM&amp;gt;&amp;quot; + getName() + &amp;quot;고객님의 대여 기록 &amp;lt;/EM&amp;gt;&amp;lt;/H1&amp;gt;&amp;lt;P&amp;gt;\n&amp;quot;;
		while(rentals.hasNext()) {
			Rental each = (Rental) rentals.next();
			
			//모든 대여 비디오 정보와 대여로를 출
			result += each.getMovie().getTitle() + &amp;quot;\t&amp;quot; + String.valueOf(each.getCharge()) + &amp;quot;&amp;lt;BR&amp;gt;\n&amp;quot;;
		}
		//footer
		result += &amp;quot;&amp;lt;P&amp;gt;누적 대여료 : &amp;lt;EM&amp;gt;&amp;quot; + String.valueOf(getTotalCharge()) + &amp;quot;&amp;lt;/EM&amp;gt;&amp;lt;/P&amp;gt;\n&amp;quot;;
		result += &amp;quot;&amp;lt;P&amp;gt;적립 포인트 : &amp;lt;EM&amp;gt;&amp;quot; + String.valueOf(getTotalFrequentRenterPoints()) + &amp;quot;&amp;lt;/EM&amp;gt;&amp;lt;/P&amp;quot;;
		return result;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;계산 부분을 빼내서 htmlStatement 메서드로 작성하면 처음의 statement메서드에 들어있던 계산 코드를 전부 재사용할 수 있다. 복사해서 붙인 중복코드가 없으니 계산식 자체를 수정해야 할 때도 한 군데만 수정하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;가격-책정-부분의-조건문을-재정의로-교체:30755030f144d3278f749327f4151410&#34;&gt;가격 책정 부분의 조건문을 재정의로 교체&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;새로운 요구사항이 생겼다. 대여점의 비디오 분류를 바꾸려고 준비 중이다. 어떻게 변경할지는 아직 결정하지는 않았지만, 분명한 건 기존과 전혀 다른 방식으로 분류하리란 것이다. 수정하는 각 비디오 분류마다 대여료와 적립 포인트의 적립 비율도 결정해야 한다. 지금 이런 식의 수정을 하기엔 무리다. 우선, 대여료 메서드와 적립 포인트 메서드부터 마무리 짓고 조건문 코드를 수정해서 비디오 분류를 변경해야 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;제일 먼저 고칠 부분은 switch 문이다. 타 객체의 속성을 switch 문의 인자로 하는 것은 나쁜 방법이다. getCharge메서드를 Movie클래스로 옮긴다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;대여기간을 Movie 클래스에 전달했는데 왜 그랬을까? 사용자가 요청한 변경이 단지 새로운 비디오 종류를 추가해 달라는 것이었기 때문이다. 비디오 종류를 변경해도 그로 인해 미치는 영향을 최소화하고자 대여료 계산을 Movie클래스 안에 넣은 것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getFrequentRenterPoints메서드도 Movie클래스로 옮긴다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;마지막-단계-상속구조-만들기:30755030f144d3278f749327f4151410&#34;&gt;마지막 단계 상속구조 만들기&lt;/h5&gt;

&lt;p&gt;-Movie 클래스는 비디오 종류에 따라 같은 메서드 호출에도 각기 다른 값을 반환한다. 그런데 이건 하위클래스가 처리할 일이다. 따라서 Movie 클래스를 상속받는 3개의 하위 클래스를 작성하고, 비디오 종류별 대여료 계산을 각 하위클래스에 넣어야 한다. (60~61p참조)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;인다이렉션(값 자체가 아니라 이름, 참조, 컨테이너 등을 사용해서 대상을 참조하는기능) 기능을 추가하면 Price 클래스 안의 코드를 하위 클래스로 만들어서 언제든 대여료를 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-Price 클래스가 나타내는 것이 대여료 계산 알고리즘인가, 아니면 비디오의 상태인가?라는 의문이 든다. 현재는 Price 클래스의 코드는 비디오의 상태라고 생각한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;상태 패턴을 적용하려면 세 가지 리팩토링 기법을 사용해야 한다. 분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy 273p)기법을 실시해서 분류 부호의 기능을 상태 패턴 안으로 옮겨야 한다. 그 다음에 메서드 이동(Move Method 178p)기법을 실시해서 switch 문을 Price 클래스 안으로 옮겨야 한다. 끝으로 조건문을 재정의로 전환(Replace Conditional with Polymorphism 305p) 기법을 실시해서 switch문을 없애야 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy 273p)기법을 실시한다. 이 기법의 첫 단계는 분류 부호에 필드 자체 캡슐화 (Self Encapsulate Field 211p)기법을 적용해서 반드시 읽기/쓰기 메서드를 거쳐서만 분류 부호를 사용할 수 있게 해야한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;_priceCode = priceCode; -&amp;gt; setPriceCode(priceCode)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일 후 문제가 없으면 Price 클래스를 상속 확장하는 클래스 3개를 추가로 작성하자.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Price {
	abstract int getPriceCode();
}


class ChildrensPrice extends Price {

	@Override
	int getPriceCode() {
		return Movie.CHILDRENS;
	}
	
}

class NewReleasePrice extends Price {

	@Override
	int getPriceCode() {
		return Movie.NEW_RELEASE;
	}
	
}

class RegularPrice extends Price {

	@Override
	int getPriceCode() {
		return Movie.REGULAR;
	}
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;이제 priceCode가 새 클래스를 사용할 수 있게 Movie클래스의 읽기/쓰기 메서드를 수정하자&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        public int getPriceCode() {
		return _price.getPriceCode();
	}
	
	public void setPriceCode(int arg){
		switch(arg) {
			case REGULAR:
				_price = new RegularPrice();
				break;
			case CHILDRENS:
				_price = new ChildrensPrice();
				break;
			case NEW_RELEASE:
				_price = new NewReleasePrice();
				break;
		}
	
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;메서드 이동(Move Method 178p)기법을 실시해서 getCharge 메서드를 옮기자&lt;/li&gt;
&lt;li&gt;이후 조건문을 재정의로 전환(Replace Conditinal with Polymorphism 305p)기법을 실시한다. 이것은 switch문에 든 case문 코드를 가져다가 재정의 메서드로 작성하면 된다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이후 getFrequentRenterPoints 메서드를 Price클래스로 옮긴다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;상태 패턴을 적용하는 작업은 이렇듯 상당히 복잡한데, 과연 이렇게까지 해서 적용할 가치가 있을까? 상태패턴을 적용하면 대여료 계산 방식을 변경하거나, 새 대여료를 추가하거나, 부수적인 대여료 관련 동작을 추가할 때 아주 쉽게 수정할 수 있다. 뿐만 아니라 프로그램의 다른 부분은 상태 패턴의 영향을 받지 않는다. 실제 큰 규모의 시스템에서는 무시할 수 없는 차이가 보인다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;정리:30755030f144d3278f749327f4151410&#34;&gt;정리&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;이장은 리팩토링이 무엇인지 어느 정도 감을 잡기 위한 장이다. 예제에서 몇가지 기법을 사용했는데. 이런 기법을 적용하면 기능 분배가 균등해지고 코드 유지보수도 쉬워진다. 가장 중요한 교훈은 &amp;lsquo;간단한 수정 -&amp;gt; 테스트&amp;rsquo;를 리듬처럼 반복해야 한다는 것이다. 이 리듬을 지킬 때만이 리팩토링을 빠르고 안정적으로 완료할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>맛보기 예제</title>
      <link>http://kwsstudy.github.io/post/%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C-%EB%8B%A8%EC%88%9C%ED%99%94/</link>
      <pubDate>Sun, 08 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C-%EB%8B%A8%EC%88%9C%ED%99%94/</guid>
      <description>&lt;p&gt;메서드명 변경 Rename Method
매개변수 추가 Add Parameter
매개변수 제거 Remove Parameter
상태 변경 메서드와 값 반환 메서드를 분리 Separate Query from Modifier
메서드를 매개변수로 전환 Parameterize Method
매개변수를 메서드로 전환 Replace Parameter with Explicit Methods
객체를 통째로 전달 Preserve Whole Object
매개변수 세트를 메서드로 전환 Replace Parameter with Method
매개변수 세트를 객체로 전환 Introduce Parameter Object
쓰기 메서드 제거 Remove Setting Method
메서드 은폐 Hide Method
생성자를 팩토리 메서드로 전환 Replace Constructor with Factory Method
하향 타입 변환을 캡슐화 Encapsulate Downcast
에러 부호를 예외 통지로 교체 Replace Error Code with Exception
예외 처리를 테스트로 교체 Replace Exception with Test&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>나머지 패턴</title>
      <link>http://kwsstudy.github.io/post/%EB%82%98%EB%A8%B8%EC%A7%80-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 03 Apr 2016 12:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EB%82%98%EB%A8%B8%EC%A7%80-%ED%8C%A8%ED%84%B4/</guid>
      <description>

&lt;h3 id=&#34;디자인-패턴의-정의:a67287062295544a289631d93d16c84e&#34;&gt;디자인 패턴의 정의?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;패턴이란 특정 &lt;strong&gt;컨텍스트&lt;/strong&gt; 내에서 주어진 &lt;strong&gt;문제&lt;/strong&gt;에 대한 &lt;strong&gt;해결책&lt;/strong&gt;이다!.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컨텍스트(context)란?
패턴이 적용되는 상황을 뜻합니다. 반복적으로 일어날 수 있는 상황이어야만 합니다.
예 : 객체들의 컬렉션이 주어져 있습니다.
   (열쇠를 차에 두고 문을 잠그고 나와 버렸다.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;문제(problem)란?
그 컨텍스트 내에서 이루고자 하는 목적을 뜻합니다. 하지만 컨텍스트 내에서 생길 수 있는 제약조건도 문제에 포함됩니다.
예 : 컬렉션의 구현을 드러내지 않으면서 그 안에 있는 각 객체들에 대해서 순환작업을 할 수 있어야 합니다.
   (어떻게 회사에 제 시간에 도착할 것인가?)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;해결책(solution)?
누구든지 적용해서 일련의 제약조건 내에서 목적을 달성할 수 있는 일반적인 디자인을 뜻합니다.
예 : 반복 작업을 별도의 클래스로 캡슐화 시킵니다.
   (유리를 깬다. 차에 들어간다. 시동을 걸고 차를 몰고 출근한다.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;()안에 있는 예는 디자인 패턴의 정의에 의하면 올바른 패턴이라고 할 수 있을까?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;없다. 이유는 1. 해결책으로 차유리를 깨는 방법은 반복적으로 적용할 수 있는 해결책이라고 할수 없으며
         2. 이런 해결책을 다른 사람한테 알려주고 그 사람이 처한 문제에 대한 해결책으로 적용하기 힘든점
         3. 패턴에 이름이 붙이지 않았기에 다른 개발자들하고 그 패턴에 대해서 토론하는 것이 불가능하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;디자인 패턴의 정의?
&amp;ldquo; 어떤 컨텍스트 내에서 일련의 제약조건에 의해 영향을 받을 수 있는 문제에 봉착했다면, 그 제약조건 내에서 목적을 달성하기 위한 해결책을 찾아낼
수 있는 디자인을 적용하면 된다. 단순히 표현하면 &lt;strong&gt;반복적으로&lt;/strong&gt; 등장하는 디자인 문제에 대한 해결책 &amp;ldquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;디자인 패턴을 정형적으로 기술해 놓아야 카탈로그?를 만들수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;패턴 카탈로그란?
가장 훌륭한 패턴 카탈로그는 Design Patterns: Elements of Reusable Object-Oriented Software -&amp;gt; GoF의 디자인패턴(한글번역         판) 이 카탈로그에는 23개의 기본 패턴이 수록&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;패턴 카탈로그의 기술 형식!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;패턴 이름
패턴 설명에서 가장 먼저 등장, 패턴의 이름 없이는 패턴에 대한 정보를 다른 개발자들과 공유하기가 아주 힘들어 진다.&lt;/li&gt;
&lt;li&gt;용도(Intent)
패턴의 역할이 간단히 기술된다.&lt;/li&gt;
&lt;li&gt;동기(Motivation)
문제를 기술하고 주어진 해결책이 어떤 식으로 그 문제를 해결 할 수 있는지를 보여줄 수 있는 구체적인 시나리오가 주어진다.&lt;/li&gt;
&lt;li&gt;적용대상(Applicability)
패턴을 적용할 수 있는 상황이 기술된다.&lt;/li&gt;
&lt;li&gt;구조(Structure)
패턴에서 사용되는 클래스 다이어그램이 수록된다.&lt;/li&gt;
&lt;li&gt;구성요소(Participant)
디자인패턴에 포함되어 있는 클래스와 객체들에 대한 설명&lt;/li&gt;
&lt;li&gt;협동(Collaboration)
각 구성요소들이 패턴 내에서 어떤 식으로 도움을 주는지 설명.&lt;/li&gt;
&lt;li&gt;결과(Consequence)
패턴을 사용했을 때의 효과(장점 및 단점)가 수록됨&lt;/li&gt;
&lt;li&gt;구현(Implementation)
패턴을 구현할 때 필요한 기술 및 주의사항에 대해 설명&lt;/li&gt;
&lt;li&gt;샘플코드(Sample Code)
구현시 도움 될 만한 코드 제공&lt;/li&gt;
&lt;li&gt;사용예(Known Uses)
실제 시스템에서 이 패턴을 사용하는 예에 대한 설명&lt;/li&gt;
&lt;li&gt;관련패턴 (Related Patterns)
본 패턴과 유사하거나 밀접하게 관련된 다른 패턴에 대해서 기술&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;디자인패턴은-만병-통치약이-아니다:a67287062295544a289631d93d16c84e&#34;&gt;디자인패턴은 만병 통치약이 아니다!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;패턴은 반복적으로 발생하는 문제에 대한 일반적인 해결책이다.&lt;/li&gt;
&lt;li&gt;다만 패턴이 필요하다고 결론을 내리고 나면 다른 개발자들도 비슷한 문제를 겪었고, 비슷한 기법을 적용해서 그 문제를 해결 했다고 생각 할 수 있다.&lt;/li&gt;
&lt;li&gt;패턴을 사용한다고 기적 같이 문제가 해결되진 않는다. 그 패턴을 사용했을 때 여러분이 설계한 디자인의 다른 부분에 미칠 수 있는 영향과
결과에 대해 주의깊게 생각해 보아야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;디자인-패턴이-필요한-경우:a67287062295544a289631d93d16c84e&#34;&gt;디자인 패턴이 필요한 경우?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;디자인상의 문제에 적합하다는 확신이 들 경우에 패턴을 도입해야한다.&lt;/li&gt;
&lt;li&gt;언제 패턴을 적용할지를 올바르게 결정하려면 상당한 경험과 지식이 축척되어야 합니다.&lt;/li&gt;
&lt;li&gt;만약 더 간단한 해결책이 있다면 패턴을 적용하기 전에 그 해결책을 사용하는 것을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;패턴을 도입하는 것은 디자인 단계에서만 고려해야 하는 일이 아니라, 리팩토링 할 때도 패턴을 고려해보는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;리팩터링과-패턴:a67287062295544a289631d93d16c84e&#34;&gt;리팩터링과 패턴&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;리팩터링이란 코드 구조를 개선하기 위해서 코드를 변경하는 과정을 뜻한다.&lt;/li&gt;
&lt;li&gt;예를들면 조건문이 아주 많이 있는 코드가 있으면 스테이트 패턴을 적용하는 것을 고려해볼만 하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;패턴을-대하는-마음가짐:a67287062295544a289631d93d16c84e&#34;&gt;패턴을 대하는 마음가짐&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;초급자
언제나 패턴을 사용하는 경향이 있습니다. Hello World 프로그램에도 패턴을 써봐야지
이러한 과정에서 패턴을 쓰는 연습을 하면서 다양한 경험을 쌓을 수 있다.&lt;/li&gt;
&lt;li&gt;중급자
경험이 늘어감에 따라 중급자 수준에 오르게 되면 어떤 상황에서 패턴이 필요하고 어떤 상황에서 패턴이 필요하지 않은지를
파악할 수 있다.&lt;/li&gt;
&lt;li&gt;달인
달인의 경지에 오르게 되면 패턴을 자연스럽게 구사할 수 있습니다.
더 이상 패턴을 사용하는 것에 얽매이지 않고, 문제를 가장 효과적으로 해결할 수 있는 해결책을 찾는데 주안점을 둘뿐!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;사악한-안티-패턴-섬멸하기:a67287062295544a289631d93d16c84e&#34;&gt;사악한 안티 패턴? 섬멸하기~!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;안티 패턴은 어떤 문제에 대한 나쁜 해결책에 이르는 길을 알려줍니다.&lt;/li&gt;
&lt;li&gt;안티 패턴에서는 어떤 이유로 나쁜 해결책에 유혹될 수 있는지를 알려줍니다.&lt;/li&gt;
&lt;li&gt;안티 패턴은 장기적인 관점에서 그 해결책이 나븐 이유를 알려줍니다.&lt;/li&gt;
&lt;li&gt;안티 패턴에서는 좋은 해결책을 만들어 내기 위해 적용할 수 있는 다른 패턴을 제안해 줍니다.&lt;/li&gt;
&lt;li&gt;page 645에 안티패턴의 예시가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;브리지-패턴:a67287062295544a289631d93d16c84e&#34;&gt;브리지 패턴&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;브리지 패턴&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;구현 뿐만 아니라 추상화된 부분까지 변경시켜야 하는 경우에는 브리지 패턴을 사용&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;인터페이스와 실행을 분리하여 독립적으로 변할 수 있게 함&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;왜 브리지 패턴을 사용하는가?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;추상화된 부분과 추상 클래스/인터페이스를 구현한 클래스를 서로 다른 클래스 계층구조에 집어 넣음으로써 그 둘을 모두 변경시킬 수 있습니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;브리지의 장점&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;구현을 인터페이스에 완전히 결합시키지 않았기 때문에 구현과 추상화된 부분을 분리시킬 수 있습니다. (기능부와 구현부를 분리)&lt;/li&gt;
&lt;li&gt;추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있습니다. (기능을 추가로 넣거나 구현을 바꿀때 독립적으로 할 수 있다.)&lt;/li&gt;
&lt;li&gt;추상화된 부분을 구현한 구상클래스를 바꿔도 클라이언트 쪽에는 영향을 끼치지 않습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;브리지 활용법 및 단점&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;여러 플랫폼에서 사용해야 할 그래픽스 및 윈도우 처리 시스템에서 유용하게 쓰입니다.&lt;/li&gt;
&lt;li&gt;인터페이스와 실제 구현부를 서로 다른 방식으로 변경해야 하는 경우에 유용하게 쓰입니다&lt;/li&gt;
&lt;li&gt;디자인이 복잡해진다는 단점이있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;빌더-패턴:a67287062295544a289631d93d16c84e&#34;&gt;빌더 패턴&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Builder Pattern은 생성자 패턴 중 하나이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>컴파운드 패턴</title>
      <link>http://kwsstudy.github.io/post/%EC%BB%B4%ED%8C%8C%EC%9A%B4%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 03 Apr 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EC%BB%B4%ED%8C%8C%EC%9A%B4%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>

&lt;h3 id=&#34;컴파운드-패턴이란:5b8821fbb3ad363c31fa474ea630b1c5&#34;&gt;컴파운드 패턴이란?&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;반복적으로 생길 수 있는 &lt;strong&gt;일반적인 문제를 해결하기 위한 용도&lt;/strong&gt;로 두 개 이상의 패턴을 결합해서 사용하는 것.
 패턴을 같이 쓴다고 무조건 컴파운드 패턴은 아니다. 문제를 해결하기 위한 용도로 사용해야 된다.
 대표적인 컴파운드 패턴은 MVC이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
//Quckable인터페이스를 구현한 클래스들

public interface Quackable {
    public void quack();
}

public class DuckCall implements Quackable{
    @Override
    public void quack() {
        System.out.println(&amp;quot;Kwak&amp;quot;);
    }
}

public class MallardDuck implements Quackable {
    @Override
    public void quack() {
        System.out.println(&amp;quot;Quack&amp;quot;);
    }
}

public class RedheadDuck implements Quackable {
    @Override
    public void quack() {
        System.out.println(&amp;quot;quack&amp;quot;);
    }
}

public class RubberDuck implements Quackable{
    @Override
    public void quack() {
        System.out.println(&amp;quot;Squeak&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;실행&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DuckSimulator {


public static void main(String [] args) {
    DuckSimulator simulator = new DuckSimulator();
    simulator.simulator();
}


void simulator() {
    Quackable mallardDuck = new MallardDuck();
    Quackable redheadDuck = new RedheadDuck();
    Quackable duckCall = new DuckCall();
    Quackable rubberDuck = new RubberDuck();


    System.out.println(&amp;quot;\nDuck Simulator&amp;quot;);


    simulator(mallardDuck);
    simulator(redheadDuck);
    simulator(duckCall);
    simulator(rubberDuck);
}


void simulator(Quackable duck) {
    duck.quack();
}
}
---------------------------------
Duck Simulator
Quack
quack
Kwak
Squeak
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;거위가 추가되었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Goose {
public void honk() {
    System.out.println(&amp;quot;Honk&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Duck를 집어 넣을 수 있는 곳이라면 어디든지 Goose도 집어 넣을 수 있어야 한다고 가정한다. 하지만 클래스가 다른데 거위를 시뮬레이터에 집어 넣어야 한다. 어떻게 해야 거위를 오리와 어울리게 할 수 있을까??&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;거위용 어댑터를 만들면 된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GooseAdapter implements Quackable {

    Goose goose;
    
    public GooseAdapter(Goose goose) {
        this.goose = goose;
    }
    
    @Override
    public void quack() {
        goose.honk();
    }
}

//DuckSimulator
Quackable gooseDuck = new GooseAdapter(new Goose());

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;어댑터-패턴-adapter-pattern-의-정의:5b8821fbb3ad363c31fa474ea630b1c5&#34;&gt;어댑터 패턴(Adapter Pattern)의 정의&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;한 클래스(어떤)의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다. 어탭터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있습니다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;어댑터는 클라이언트로부터 요청을 받아서 새로운 업체에서 제공하는 클래스에서 받아들일 수 있는 형태의 요청으로 변환시켜주는 중개인 역할을 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;꽥소리를 낸 횟수를 세주는 기능을 추가해야 한다.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;어떻게 해야할까??&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;소리의 횟수를 세는 기능을 가진 데코레이터 객체를 만들어서 오리 객체들을 감싸면 된다. 그러면 Duck객체들을 건드리지 않아도 된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//데코레이터 객체
public class QuackCounter implements Quackable{
    Quackable duck;
    static int numberOfQuacks;
    
    public QuackCounter(Quackable duck) {
        this.duck = duck;
    }
    
    @Override
    public void quack() {
        duck.quack();
        numberOfQuacks++;
    }

    public static int getQuacks() {
        return numberOfQuacks;
    }
}

//실행
public class DuckSimulator {
    
    public static void main(String [] args) {
        DuckSimulator simulator = new DuckSimulator();
        simulator.simulator();
    }
    
    
    void simulator() {
        Quackable mallardDuck = new QuackCounter(new MallardDuck());
        Quackable redheadDuck = new QuackCounter(new RedheadDuck());
        Quackable duckCall = new QuackCounter(new DuckCall());
        Quackable rubberDuck = new QuackCounter(new RubberDuck());
        Quackable gooseDuck = new GooseAdapter(new Goose());
        
        System.out.println(&amp;quot;\nDuck Simulator&amp;quot;);
        
        simulator(mallardDuck);
        simulator(redheadDuck);
        simulator(duckCall);
        simulator(rubberDuck);
        simulator(gooseDuck);
        
        System.out.println(&amp;quot;The Ducks quacked &amp;quot; + QuackCounter.getQuacks() + &amp;quot; times&amp;quot;);
    }
    
    void simulator(Quackable duck) {
        duck.quack();
    }
}

-----------------------------
Duck Simulator
Quack
quack
Kwak
Squeak
Honk
The Ducks quacked 4 times
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;decorator-pattern의-정의:5b8821fbb3ad363c31fa474ea630b1c5&#34;&gt;Decorator Pattern의 정의&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;데코레이터 패턴에서는 객체에 추가적인 요건을 동적으로 첨가한다. (즉 자신이 장식하고 있는
      객체에게 어떤 행동을 위임하는 것 외에 원하는 추가적인 작업을 수행할 수 있다.)&lt;/li&gt;
&lt;li&gt;데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.&lt;/li&gt;
&lt;li&gt;한마디로 기존 구현되어있는 클래스에 기능을 추가하기위한 패턴이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;새로운 문제점&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;데코레이터를 쓸 때는 객체들을 제대로 포장하지 않으면 원하는 행동을 추가할 수 없다.&lt;/li&gt;
&lt;li&gt;그렇다면 오리 객체를 생성하는 작업을 한 군데에 몰아서 하는건 어떨까? 오리를 생성하고 데코레이터로 감싸는 부분을 따로 빼내서 캡슐화를 하자.&lt;/li&gt;
&lt;li&gt;모든 오리들이 데코레이터로 감싸지도록 할 수 있는 방법이 필요하다. 그렇게 하는 데는 팩토리를 만드는게 제격이다. 이 팩토리에서는 여러 종류의 오리들을 생산해야 할 테니깐 추상 팩토리 패턴을 사용하자&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class AbstractDuckFactory {
    
    public abstract Quackable createMallardDuck();
    public abstract Quackable createRedheadDuck();
    public abstract Quackable createDuckCall();
    public abstract Quackable createRubberDuck();
}

public class CountingDuckFactory extends AbstractDuckFactory{

    @Override
    public Quackable createMallardDuck() {
        return new QuackCounter(new MallardDuck());
    }

    @Override
    public Quackable createRedheadDuck() {
        return new QuackCounter(new RedheadDuck());
    }

    @Override
    public Quackable createDuckCall() {
        return new QuackCounter(new DuckCall());
    }

    @Override
    public Quackable createRubberDuck() {
        return new QuackCounter(new RubberDuck());
    }
}

public class DuckSimulator {
    
    public static void main(String [] args) {
        DuckSimulator simulator = new DuckSimulator();
        AbstractDuckFactory duckFactory = new CountingDuckFactory();
        simulator.simulator(duckFactory);
    }
    
    
    void simulator(AbstractDuckFactory duckFactory) {
        Quackable mallardDuck = duckFactory.createMallardDuck();
        Quackable redheadDuck = duckFactory.createRedheadDuck();
        Quackable duckCall = duckFactory.createDuckCall();
        Quackable rubberDuck = duckFactory.createRubberDuck();
        Quackable gooseDuck = new GooseAdapter(new Goose());
        
        System.out.println(&amp;quot;\nDuck Simulator&amp;quot;);
        
        simulator(mallardDuck);
        simulator(redheadDuck);
        simulator(duckCall);
        simulator(rubberDuck);
        simulator(gooseDuck);
        
        System.out.println(&amp;quot;The Ducks quacked &amp;quot; + QuackCounter.getQuacks() + &amp;quot; times&amp;quot;);
    }
    
    void simulator(Quackable duck) {
        duck.quack();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##추상 팩토리 (Abstract Factory)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;위와-같이-문제를-해결하기-위해서-여러-패턴을-사용하는-것이-컴파운드-패턴이다:5b8821fbb3ad363c31fa474ea630b1c5&#34;&gt;위와 같이 문제를 해결하기 위해서 여러 패턴을 사용하는 것이 컴파운드 패턴이다.&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>컴파운드 패턴-MVC</title>
      <link>http://kwsstudy.github.io/post/MVC/</link>
      <pubDate>Sun, 03 Apr 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/MVC/</guid>
      <description>

&lt;h3 id=&#34;mp3에대한-mvc:bb96ab302b765ef4c09d5a4a084243bd&#34;&gt;MP3에대한 MVC&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KWSStudy/DesignPartterns/0678b828cb148776111851ab30fcaa4f100eb075/images/model-view-controller-p567.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;디자인-패턴의-관계에서-바라본-mvc:bb96ab302b765ef4c09d5a4a084243bd&#34;&gt;디자인 패턴의 관계에서 바라본 MVC&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/KWSStudy/DesignPartterns/blob/master/images/mvc.png?raw=true&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;사용자는 뷰하고만 접촉할 수 있다.&lt;/li&gt;
&lt;li&gt;컨트롤러에서 모델한테 상태를 변경하라는 요청을 한다.&lt;/li&gt;
&lt;li&gt;컨트롤러에서 뷰를 변경해 달라고 요청할 수도 있다.&lt;/li&gt;
&lt;li&gt;상태가 변경되면 모델에서 뷰한테 그 사실을 알린다.&lt;/li&gt;
&lt;li&gt;뷰에서 모델한테 상태를 요청한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;패턴-안경을-끼고-mvc를-살펴보자:bb96ab302b765ef4c09d5a4a084243bd&#34;&gt;패턴 안경을 끼고 MVC를 살펴보자&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/KWSStudy/DesignPartterns/blob/master/images/mvc2.png?raw=true&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;스트래티지 패턴의 적용 원칙&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자주 바뀌는 부분(기능)을 바뀌지 않는 부분과 분리하여 캡슐화 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;스트래티지 패턴(뷰와 컨트롤러) - 뷰 객체를 여러 전략을 써서 제공한다. 전략은 컨트롤러가 제공한다. 뷰에서는 애플리케이션의 겉모습에만 신경을 쓰고, 인터페이스의 행동에 대한 결정은 모두 컨트롤러한테 맡긴다. 스트래티지 패턴을 사용하는 것은 뷰를 모델로부터 분리시키는데 도움이 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴포지트 패턴(뷰) - 디스플레이는 여러 단계로 겹쳐져 있을 수 있는 일련의 윈도우, 패널 버튼, 텍스트 레이블 등으로 구성된다. 각 디스플레이 항목은 복합객체 또는 잎이 될 수 있다. 컨트롤러에서 뷰한테 화면을 갱신해 달라고 요청하면 최상위 뷰 구성요소한테만 화면을 갱신하라고 애기하면 된다. 나머지는 컴포지트 패턴에 의해 자동으로 처리된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;옵저버패턴(모델) - 모델에서는 옵저버 패턴을 써서 상태가 변경되었을 때 그 모델하고 연관된 객체들한테 연락을 한다. 옵저버 패턴을 사용하면 모델을 뷰 및 컨트롤러로부터 완전히 독립시킬 수 있다. 한 모델에서 서로 다른 뷰를 사용할 수도 있고, 심지어 여러 개의 뷰를 동시에 사용하는 것도 가능하다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/KWSStudy/DesignPartterns/blob/master/images/observer.png?raw=true&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://github.com/KWSStudy/DesignPartterns/blob/master/images/strategy.png?raw=true&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://github.com/KWSStudy/DesignPartterns/blob/master/images/composite.png?raw=true&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프록시 패턴</title>
      <link>http://kwsstudy.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 27 Mar 2016 12:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>

&lt;h3 id=&#34;정의:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;정의&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴&lt;/li&gt;
&lt;li&gt;클라이언트에서 메소드 호출시 호출을 중간에 가로채어 메소드 호출/ 접근제한등을 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;프록시-종류:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;프록시 종류&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;원격(Remote Proxy) 프록시&lt;/li&gt;
&lt;li&gt;가상(Virtual Proxy) 프록시&lt;/li&gt;
&lt;li&gt;동적(Dynamic Proxy) 프록시&lt;/li&gt;
&lt;li&gt;보호(Protection Proxy) 프록시&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;원격-remote-proxy-프록시:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;원격(Remote Proxy) 프록시&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;다른 jvm에 들어있는 객체의 대변인에 해당하는 로컬 객체.&lt;/li&gt;
&lt;li&gt;프록시의 메소드를 호출하면, 그호출이 네트워크를 통해 전달되어 원격객체의 메소드가 호출, 결과는 프록시를 통해 클라이언트에게 전달됨.
&lt;img src=&#34;http://kwsstudy.github.io/DesignPartterns/remote.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;가상-virtual-proxy-프록시:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;가상(Virtual Proxy) 프록시&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;생성비용이 많이드는 객체를 대신하는 역할.&lt;/li&gt;
&lt;li&gt;진짜 객체가 필요하기 전까지 객체의 생성을 미루거나, 생성 전/중 진짜 객체를 대신한다.&lt;/li&gt;
&lt;li&gt;객체 생성 후 요청을 진짜 객체에게 직접 전달.
&lt;img src=&#34;http://kwsstudy.github.io/DesignPartterns/virtual.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;동적-dynamic-proxy-프록시:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;동적(Dynamic Proxy) 프록시&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;자바에 내장된 reflect 패키지를 이용하여, 즉석에서 한개이상의 인터페이스를 구현하여 메소드 호출을 지정한 클래스에 전달하는 프록시 클래스를 만드는 패턴&lt;/li&gt;
&lt;li&gt;실제 프록시 클래스는 실행중에 생성됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;보호-protection-proxy-프록시:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;보호(Protection Proxy) 프록시&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;접근 권한을 바탕으로 객체에 대한 접근을 제어하는 프록시
&lt;img src=&#34;http://kwsstudy.github.io/DesignPartterns/protection.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;프록시패턴의-종류와-사용되는곳을-찾아보자:2e0acdb1838716c12dbc3fa22a5850f7&#34;&gt;프록시패턴의 종류와 사용되는곳을 찾아보자&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/KWSStudy/DesignPartterns/tree/master/src/com/kws/proxy&#34;&gt;샘플소스확인&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.co.kr/webhp?sourceid=chrome-instant&amp;amp;ion=1&amp;amp;espv=2&amp;amp;ie=UTF-8#q=java%20reflection&#34;&gt;reflection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.co.kr/webhp?sourceid=chrome-instant&amp;amp;ion=1&amp;amp;espv=2&amp;amp;ie=UTF-8#q=spring+aop+proxy+pattern&#34;&gt;spring aop proxy pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;프록시 패턴의 종류 책 526P.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스테이트 패턴</title>
      <link>http://kwsstudy.github.io/post/%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 27 Mar 2016 11:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>

&lt;h1 id=&#34;스테이트-state-패턴:2c82a25a48e7f5639b430349a57c69f5&#34;&gt;스테이트(State) 패턴&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;스테이트 패턴&lt;/strong&gt;을 이용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을
바꿀 수 있습니다.&lt;br /&gt;
마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://www.googledrive.com/host/0Byw6XXFkbgXWdVoxdHp1SWpsVzQ&#34; alt=&#34;스테이트패턴&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;뽑기-기계의-상태-변화:2c82a25a48e7f5639b430349a57c69f5&#34;&gt;뽑기 기계의 상태 변화&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://www.googledrive.com/host/0Byw6XXFkbgXWRG16OGdTTlhNdVE&#34; alt=&#34;상태변화&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;객체의 상태에 따라서 실행되는 행위가 달라져야 할 때&lt;/em&gt;&lt;br /&gt;
→ 객체 내부에서 &lt;code&gt;if&lt;/code&gt; 절 또는 &lt;code&gt;switch - case&lt;/code&gt; 절 의 전개&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 동전을 투입하는 행위
public void insertQuarter() {
  if (state == HAS_QUARTER) {
    System.out.println(&amp;quot;동전은 한 개만 넣어주세요.&amp;quot;);
  } else if (state == NO_QUARTER) {
    state = HAS_QUARTER;
    System.out.println(&amp;quot;동전을 넣었습니다.&amp;quot;);
  } else if (state == SOLD_OUT) {
    System.out.println(&amp;quot;매진되었습니다. 다음 기회에 이용해주세요.&amp;quot;);
  } else if (state == SOLD) {
    System.out.println(&amp;quot;잠깐만 기다려 주세요. 알맹이가 나가고 있습니다.&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;모든 행위들 마다 위와 같은 코드가 반복되어야 함&lt;/em&gt;&lt;br /&gt;
→ 상태 자체를 객체로 만들면 어떨까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.googledrive.com/host/0Byw6XXFkbgXWNmtybTZGTkVoNnc&#34; alt=&#34;뽑기기계 스테이트패턴&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 상태를 나타내는 객체들이 구현할 인터페이스
public interface State {
  
  void insertQuarter();

  void ejectQuarter();

  void turnCrank();

  void dispense();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;각 상태들을 구현한다면&lt;/em&gt;&lt;br /&gt;
→ 해당 상태의 코드만 적용하면 됨&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SoldState implements State {
  GumballMachine gumballMachine;

  public SoldState(GumballMachine gumballMachine) {
    this.gumballMachine = gumballMachine;
  }

  @Override
  public void insertQuarter() {
    System.out.println(&amp;quot;잠깐만 기다려 주세요. 알맹이가 나가고 있습니다.&amp;quot;);
  }

  @Override
  public void ejectQuarter() {
    System.out.println(&amp;quot;이미 알맹이를 뽑으셨습니다.&amp;quot;);
  }

  @Override
  public void turnCrank() {
    System.out.println(&amp;quot;손잡이는 한 번만 돌려주세요.&amp;quot;);
  }

  @Override
  public void dispense() {
    gumballMachine.releaseBall();
    if (gumballMachine.getCount() &amp;gt; 0) {
      gumballMachine.setState(gumballMachine.getNoQuarterState());
    } else {
      System.out.println(&amp;quot;매진입니다.&amp;quot;);
      gumballMachine.setState(gumballMachine.getSoldOutState());
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래 코드로 &lt;code&gt;GumballMachine&lt;/code&gt; 객체 내부의 상태 객체를 변화 시킴&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;gumballMachine.setState(gumballMachine.getNoQuarterState());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;→ &lt;code&gt;GumballMachine&lt;/code&gt;을 사용하는 클라이언트 입장에서는 &lt;em&gt;객체의 클래스가 바뀌는 것 처럼 느낄 수 있음&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&#34;gameballmachine-의-메서드를-state-인터페이스가-왜-대부분-가져가는가:2c82a25a48e7f5639b430349a57c69f5&#34;&gt;&lt;code&gt;GameballMachine&lt;/code&gt;의 메서드를 &lt;code&gt;State&lt;/code&gt;인터페이스가 왜 대부분 가져가는가?&lt;/h5&gt;

&lt;p&gt;스테이트 패턴은 _내부 상태에 따라서 변화되는 행위를 추상화하는 것_이므로,&lt;br /&gt;
상태에 따라 변화되는 행위들을 모두 담아야 한다.&lt;/p&gt;

&lt;h5 id=&#34;다이어그램은-스트래티지패턴과-동일한-것-같은데:2c82a25a48e7f5639b430349a57c69f5&#34;&gt;다이어그램은 스트래티지패턴과 동일한 것 같은데?&lt;/h5&gt;

&lt;p&gt;스트래티지는 구성을 이용하여 상속을 대체하는 것이라면,&lt;br /&gt;
스테이트는 수많은 조건문의 대체하는 것이라고 보면 됨&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>이터레이터와 컴포지트 패턴</title>
      <link>http://kwsstudy.github.io/post/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0%EC%99%80-%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 20 Mar 2016 12:00:00 +0900</pubDate>
      
      <guid>http://kwsstudy.github.io/post/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0%EC%99%80-%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>

&lt;h3 id=&#34;이터레이터-패턴의-정의:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;이터레이터 패턴의 정의&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;이터레이터 패턴은 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공한다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이 패턴을 이용하면 집합체 내에서 어떤 식으로 일이 처리되는지에 대해서 전혀 모르는 상태에서 그 안에 들어있는 모든 항목들에 대해서 반복작업을 수행할 수 있다. 컬렉션 객체 안에 들어있는 모든 항목에 접근하는 방식이 통일되어 있으면 어떤 종류의 집합체에 대해서도 사용할 수 있는 다형적인 코드를 만들 수 있기 때문이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;쉽게 설명하면 컬렉션들을 공통된 인터페이스를 구현하게 함으로써 공통된 방법으로 모든 항목에 접근할 수 있는 방법이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;이터레이터를-사용하지-않을-경우-문제-예:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;이터레이터를 사용하지 않을 경우 문제 예&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;MenuItem이라는 클래스로 하나의 메뉴를 구현한다.&lt;/li&gt;
&lt;li&gt;PancakeHouseMenu는 List로 Diner는 배열을 이용해서 구현하였다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kws.iterate;

public class MenuItem {
    String name;
    String description;
    boolean vegetarian;
    double price;
    
    public MenuItem(String name, String description, boolean vegetarian, double price) {
        this.name = name;
        this.description = description;
        this.vegetarian = vegetarian;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public double getPrice() {
        return price;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kws.iterate;

import java.util.ArrayList;

public class PancakeHouseMenu {
    ArrayList&amp;lt;MenuItem&amp;gt; menuItems;

    public PancakeHouseMenu() {
        menuItems = new ArrayList();
        
        addItem(&amp;quot;K&amp;amp;B 팬케이크 세트&amp;quot;,
                &amp;quot;스크램블드 에그와 토스트가 곁들여진 팬케이크&amp;quot;,
                true,
                2.99);
        
        addItem(&amp;quot;레귤러 팬케이크 세트&amp;quot;,
                &amp;quot;달걀 후라이와 소시지가 곁들여진 팬케이크&amp;quot;,
                true,
                2.99);
        
        addItem(&amp;quot;블루베리 팬케이크&amp;quot;,
                &amp;quot;신선한 블루베리와 블루베리 시럽으로 만든 팬케이크&amp;quot;,
                true,
                3.49);
        
        addItem(&amp;quot;블루베리 팬케이크&amp;quot;,
                &amp;quot;와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.&amp;quot;,
                true,
                3.59);
    }

    public void addItem(String name, String description, boolean vegetarian, double price) {
        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
        menuItems.add(menuItem);
    }
    
    public ArrayList&amp;lt;MenuItem&amp;gt; getMenuItems() {
        return menuItems;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kws.iterate;

public class DinerMenu {
    static final int MAX_ITEMS = 6;
    int numberOfItems = 0;
    MenuItem[] menuItems;
    
    public DinerMenu() {
        menuItems = new MenuItem[MAX_ITEMS];
        
        
    }
    
    public void addItem(String name, String description, boolean vegetarian, double price) {
        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
        if (numberOfItems &amp;gt;= MAX_ITEMS) {
            System.out.println(&amp;quot;죄송합니다, 메뉴가 꽉 찼습니다. 더 이상 추가할 수 없습니다.&amp;quot;);
        }
        else {
            menuItems[numberOfItems] = menuItem;
            numberOfItems++;
        }
    }

    public MenuItem[] getMenuItems() {
        return menuItems;
    }
    
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;위의 두개의 메뉴를 사용하는 클라이언트가 있을 경우 어떤 문제점이 생길 수 있을까??&lt;/li&gt;
&lt;li&gt;클라이언트의 사용하게 될 메서드.
```java
printMenu()&lt;/li&gt;
&lt;li&gt;메뉴에 있는 모든 항목 출력
printBreakfastMenu();&lt;/li&gt;
&lt;li&gt;아침 항목 출력
printLunchMenu()&lt;/li&gt;
&lt;li&gt;점심 항목 출력
printVegetarianMenu();&lt;/li&gt;

&lt;li&gt;&lt;p&gt;채식주의자용 항목 출력
isItemVegetarian(name)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;채식주의자인지 판단
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;만약 PrintMenu를 구현해야 한다면 PancakeHouseMenu와 DinerMenu의 getMenuItem() 메소드를 호출해서 메뉴 항목을 가져와야 하는데
리턴형식이 하나는 배열이고 하나는 리스트이기 때문에 각각의 순환문으로 돌려서 데이터를 추출해야 한다. 현재 두개의 클래스만 가져와야 하는 상태이기 때문에 두개만 각각 구현하면 되지만 위와 같은 클래스들이 많이 생기게 되고 컬렉션 타입이 다를경우 모두 각각 구현해주어야 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이것을 해결 하기 위해서는 각 메뉴에 대한 똑같은 인터페이스를 구현할 수 있게 해주면 된다. 이것을 적용하게 되면 이터레이터 패턴이 된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;이터레이터-패턴의-적용:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;이터레이터 패턴의 적용&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Iterator {
    boolean hasNext();
    Object next();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DinerMenuIterator implements Iterator {
    MenuItem[] items;
    int position = 0;
    
    public DinerMenuIterator(MenuItem[] items) {
        this.items = items;
    }

    @Override
    public boolean hasNext() {
        if (position &amp;gt;= items.length || items[position] == null ) {
            return false;
        }
        else {
            return true;
        }
    }

    @Override
    public Object next() {
        MenuItem menuItem = items[position];
        position++;
        return menuItem;
    }
}

//DinerMenu클래스
public Iterator createIterator() {
        return new DinerMenuIterator(menuItems);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Waitress {
    PancakeHouseMenu pancakeHouseMenu;
    DinerMenu dinerMenu;
    
    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {
        this.pancakeHouseMenu = pancakeHouseMenu;
        this.dinerMenu = dinerMenu;
    }
    
    public void printMenu() {
        Iterator pancakeIterator = pancakeHouseMenu.createIterator();
        Iterator dinerIterator = dinerMenu.createIterator();
        System.out.println(&amp;quot;아침메뉴 \n====&amp;quot;);
        printMenu(pancakeIterator);
        
        System.out.println(&amp;quot;\n점심메뉴 \n====&amp;quot;);
        printMenu(dinerIterator);
    }
    
    private void printMenu(Iterator iterator) {
        while(iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            System.out.print(menuItem.getName() + &amp;quot;, &amp;quot;);
            System.out.print(menuItem.getPrice() + &amp;quot;-- &amp;quot;);
            System.out.println(menuItem.getDescription());
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MenuTest {
    public static void main(String [] args) {
        PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
        DinerMenu dinerMenu = new DinerMenu();
        
        Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu);
        waitress.printMenu();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;웨이트리스와 메뉴 분리시키기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Menu생성
public interface Menu {
    public Iterator createIterator();
}

public class Waitress {
    Menu pancakeHouseMenu;
    Menu dinerMenu;
    
    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {
        this.pancakeHouseMenu = pancakeHouseMenu;
        this.dinerMenu = dinerMenu;
    }
    
    public void printMenu() {
        Iterator pancakeIterator = pancakeHouseMenu.createIterator();
        Iterator dinerIterator = dinerMenu.createIterator();
        System.out.println(&amp;quot;아침메뉴 \n====&amp;quot;);
        printMenu(pancakeIterator);
        
        System.out.println(&amp;quot;\n점심메뉴 \n====&amp;quot;);
        printMenu(dinerIterator);
    }
    
    private void printMenu(Iterator iterator) {
        while(iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            System.out.print(menuItem.getName() + &amp;quot;, &amp;quot;);
            System.out.print(menuItem.getPrice() + &amp;quot;-- &amp;quot;);
            System.out.println(menuItem.getDescription());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;단일-역할-원칙:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;단일 역할 원칙&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;집합체에서 내부 컬렉션과 관련된 기능과 반복자용 메소드 관련 기능을 전부 구현하도록 했다면 어떨까??&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이 방법은 좋은 방법이 아닌데 클래스의 역할 외에 다른 역할을 처리하도록 하면, 두 가지 이유로 인해 그 클래스가 바뀔 수 있다. 이유는 내부컬렉션과 반복자용 메서드 관련 기능이 바뀌면 클래스가 바뀌어야 한다. 이런 이유로 &amp;ldquo;변경&amp;rdquo;이라는 주제와 관련된 디자인 원칙이 있다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;위코드의-단점:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;위코드의 단점&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator pancakeIterator = pancakeHouseMenu.createIterator();
Iterator dinerIterator = dinerMenu.createIterator();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;createIterator을 반복호출을 해야한다.&lt;/li&gt;
&lt;li&gt;그러므로 여러 메뉴를 한꺼번에 관리할 수 있는 방법이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;처리방법:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;처리방법&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Waitress {
    
    ArrayList&amp;lt;Menu&amp;gt; menus;
    
    public Waitress(ArrayList&amp;lt;Menu&amp;gt; menus) {
        this.menus = menus;
    }
    
    
    public void printMenu() {
        
        Iterator&amp;lt;Menu&amp;gt; menuIterator = menus.iterator();
        while (menuIterator.hasNext()) {
            Menu menu = menuIterator.next();
            printMenu(menu.createIterator());
            
        }
    }
    
    private void printMenu(Iterator&amp;lt;MenuItem&amp;gt; iterator) {
        while(iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            System.out.print(menuItem.getName() + &amp;quot;, &amp;quot;);
            System.out.print(menuItem.getPrice() + &amp;quot;-- &amp;quot;);
            System.out.println(menuItem.getDescription());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;위처리시-문제점:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;위처리시 문제점&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;메뉴가 여러개인것은 해결했지만 MenuItem이라는 특정한 형식이 있기 때문에 메뉴에 서브 메뉴를 추가할 수가 없다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이것을 해결 하기 위해서는 새로운 디자인이 필요하다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메뉴, 서브메뉴, 메뉴 항목 등을 모두 집어 넣을 수 있는 트리 형태의 구조가 필요하다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;각 메뉴에 있는 모든 항목에 대해서 돌아가면서 어떤 작업을 할 수 있는 방법을 제공해야 하며, 그 방법은 적어도 지금 사용중인 반복자 정도로 편리해야만 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;더 유연한 방법으로 아이템에 대해서 반복작업을 수행할 수 있어야 한다. 예를 들어, 식당 메뉴에 껴있는 디저트 메뉴에 대해서만 반복 작업을 한다거나 디저트 서브메뉴를 포함한, 메뉴 전체에 대해서 반복작업을 하는 것도 가능해야 한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;컴포지트-패턴의-정의:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;컴포지트 패턴의 정의&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;컴포지트 패턴을 이용하면 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있다. 이 패턴을 이용하면 클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체(composite)를 똑같은 방법으로 다룰 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;컴포지트-패턴을-적용한-코드:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;컴포지트 패턴을 적용한 코드&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MenuComponent {
    public void add(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }
    public void remove(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }
    public MenuComponent getChild(int i) {
        throw new UnsupportedOperationException();
    }
    
    public String getName() {
        throw new UnsupportedOperationException();
    }
    public String getDescription() {
        throw new UnsupportedOperationException();
    }
    public double getPrice(){
        throw new UnsupportedOperationException();
    }
    public boolean isVegetarian() {
        throw new UnsupportedOperationException();
    }
    public void print(){
        throw new UnsupportedOperationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Menu extends MenuComponent {
    ArrayList&amp;lt;MenuComponent&amp;gt; menuComponents = new ArrayList&amp;lt;&amp;gt;();
    String name;
    String description;
    
    public Menu(String name, String description) {
        this.name = name;
        this.description = description;
    }

    @Override
    public void add(MenuComponent menuComponent) {
        menuComponents.add(menuComponent);
    }

    @Override
    public void remove(MenuComponent menuComponent) {
        menuComponent.remove(menuComponent);
    }

    @Override
    public MenuComponent getChild(int i) {
        return menuComponents.get(i);
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDescription() {
        return description;
    }
    
    public void print() {
        System.out.print(&amp;quot;\n&amp;quot; + getName());
        System.out.println(&amp;quot;, &amp;quot; + getDescription());
        System.out.println(&amp;quot;------------------------&amp;quot;);
        
        Iterator&amp;lt;MenuComponent&amp;gt; iterator = menuComponents.iterator();
        while (iterator.hasNext()) {
            MenuComponent menuComponent = iterator.next();
            menuComponent.print();
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MenuItem extends MenuComponent {
    String name;
    String description;
    boolean vegetarian;
    double price;
    
    public MenuItem(String name, String description, boolean vegetarian, double price){
        this.name = name;
        this.description = description;
        this.vegetarian = vegetarian;
    }
    
    public String getName() {
        return name;
    }
    
    public String getDescription() {
        return description;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public double getPrice() {
        return price;
    }
    
    
    public void print() {
        System.out.print(&amp;quot;  &amp;quot; + getName());
        if(isVegetarian()) {
            System.out.print(&amp;quot;(v)&amp;quot;);
        }
        System.out.println(&amp;quot;, &amp;quot; + getPrice());
        System.out.println(&amp;quot;    -- &amp;quot; + getDescription());
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Waitress {
    MenuComponent allMenus;
    
    public Waitress(MenuComponent allMenus) {
        this.allMenus = allMenus;
    }
    
    public void printMenu() {
        allMenus.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MenuTest {
    public static void main(String [] args) {
        MenuComponent pancakeHouseMenu = new Menu(&amp;quot;팬케이크 하우스 메뉴&amp;quot;, &amp;quot;아침 메뉴&amp;quot;);
        MenuComponent dinerMenu = new Menu(&amp;quot;객체마을 식당 메뉴&amp;quot;, &amp;quot;점심 메뉴&amp;quot;);
        MenuComponent cafeMenu = new Menu(&amp;quot;카페메뉴&amp;quot;, &amp;quot;저녁메뉴&amp;quot;);
        MenuComponent dessertMenu = new Menu(&amp;quot;디저트 메뉴&amp;quot;, &amp;quot;디저트를 즐겨 보세요!&amp;quot;);
        
        MenuComponent allMenus = new Menu(&amp;quot;전체메뉴&amp;quot;, &amp;quot;전체메뉴&amp;quot;);
        
        allMenus.add(pancakeHouseMenu);
        allMenus.add(dinerMenu);
        allMenus.add(cafeMenu);
        
        
        dinerMenu.add(new MenuItem(&amp;quot;파스타&amp;quot;, &amp;quot;마리나라 소스 스파게티. 효모빵도 드립니다.&amp;quot;,
                true, 3.89));
        dinerMenu.add(new MenuItem(&amp;quot;파스타&amp;quot;, &amp;quot;마리나라 소스 스파게티. 효모빵도 드립니다.&amp;quot;,
                true, 3.89));
        dinerMenu.add(new MenuItem(&amp;quot;파스타&amp;quot;, &amp;quot;마리나라 소스 스파게티. 효모빵도 드립니다.&amp;quot;,
                true, 3.89));
        
        dinerMenu.add(dessertMenu);
        
        dessertMenu.add(new MenuItem(&amp;quot;애플파이&amp;quot;, &amp;quot;바삭바삭한 크러스트에 바닐라 아이스크림이 얹혀 있는 애플파이&amp;quot;, true, 1.59));
        dessertMenu.add(new MenuItem(&amp;quot;애플파이&amp;quot;, &amp;quot;바삭바삭한 크러스트에 바닐라 아이스크림이 얹혀 있는 애플파이&amp;quot;, true, 1.59));
        dessertMenu.add(new MenuItem(&amp;quot;애플파이&amp;quot;, &amp;quot;바삭바삭한 크러스트에 바닐라 아이스크림이 얹혀 있는 애플파이&amp;quot;, true, 1.59));
        dessertMenu.add(new MenuItem(&amp;quot;애플파이&amp;quot;, &amp;quot;바삭바삭한 크러스트에 바닐라 아이스크림이 얹혀 있는 애플파이&amp;quot;, true, 1.59));
        dessertMenu.add(new MenuItem(&amp;quot;애플파이&amp;quot;, &amp;quot;바삭바삭한 크러스트에 바닐라 아이스크림이 얹혀 있는 애플파이&amp;quot;, true, 1.59));
        
        Waitress waitress = new Waitress(allMenus);
        waitress.printMenu();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;위에서는 한 클래스는 한 역할만 해야 한다고 했는데 잘못된 방법이 아닌가?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴포지트 패턴에서는 단일 역할 원칙을 깨면서 대신에 투명성을 확보하기 위한 패턴이라고 할 수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Component 인터페이스에 자식들을 관리하기 위한 기능과 잎으로써의 기능을 전부 집어넣음으로써 클라이언트에서 복합 객체와 잎 노드를 똑같은 방식으로 처리할 수 있도록 할 수 있다. 어떤 원소가 복합 객체인지 잎 노드인지가 클라이언트 입장에서는 투명하게 느껴지는 것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;상황에 따라 원칙을 적절하게 사용해야 한다는 것을 보여주는 대표적인 사례라고 할 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;이터레이터와-복합-반복자-추가:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;이터레이터와 복합 반복자 추가&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Menu extends MenuComponent {
        //그대로
    public Iterator&amp;lt;MenuComponent&amp;gt; createIterator() {
        return new CompositeIterator(menuComponents.iterator());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MenuItem extends MenuComponent {
        //나머지코드 그대로
        public Iterator&amp;lt;MenuComponent&amp;gt; createIterator(){
        return new NullIterator();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//핵심 복합 반복자
public class CompositeIterator implements Iterator&amp;lt;MenuComponent&amp;gt;{
    Stack&amp;lt;Iterator&amp;lt;MenuComponent&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
    
    public CompositeIterator(Iterator&amp;lt;MenuComponent&amp;gt; iterator){
        stack.push(iterator);
    }

    @Override
    public boolean hasNext() {
        if(stack.empty()){
            return false;
        }
        else {
            Iterator&amp;lt;MenuComponent&amp;gt; iterator = stack.peek();
            if(!iterator.hasNext()) {
                stack.pop();
                return hasNext();
            }
            else {
                return true;
            }
        }
    }

    @Override
    public MenuComponent next() {
        if(hasNext()) {
            Iterator&amp;lt;MenuComponent&amp;gt; iterator = stack.peek();
            MenuComponent component = iterator.next();
            if (component instanceof Menu) {
                stack.push(((Menu) component).createIterator());
            }
            return component;
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;널 반복자를 만든이유&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그냥 null을 리턴할 경우 클라이언트는 null을 체크해야 하지만 아무것도 하지 않은 널 반복자를 만들경우는 동일한 로직으로 처리를 할 수 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;복합객체란&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;마지막 노드가 아닌 자식노드가 여러개 존재할 수 있는 객체이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;컴포지트-패턴-정리:9f1be646a2bb6ba10baba8565b3f7b0d&#34;&gt;컴포지트 패턴 정리&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;부분-전체 관계를 가지는 컬렉션이 있고, 그 객체들을 모두 똑같은 방식으로 다루고 싶을 때 쓰이는 패턴이다.&lt;/li&gt;
&lt;li&gt;구성요소들은 개별객체와 복합객체이다.&lt;/li&gt;
&lt;li&gt;컴포지트 패턴을 적용할 때는 여러가지 장단점을 고려해야 한다. 상황에 따라 투명성과 안정성 사이에서 적절한 평형점을 찾아야 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>